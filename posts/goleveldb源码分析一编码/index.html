<!DOCTYPE html>
<html lang="zh-cn">

<head>
  <meta charset="utf-8">
  <meta name="generator" content="Hugo 0.96.0" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="">
  <meta property="og:url" content="https://wuliuqii.github.io/posts/goleveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%80%E7%BC%96%E7%A0%81/">

  <title>Goleveldb源码分析（一）编码 - wuliuqi</title>
  <meta property="og:title" content="Goleveldb源码分析（一）编码 - wuliuqi">
  <meta property="og:type" content="article">
  <meta name="description" content="">

  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Arvo:400,700">
  <link rel="stylesheet" href="/css/highlight.css">
  <link rel="stylesheet" href="/css/journal.css">
  <link href="/index.xml" rel="alternate" type="application/rss+xml" title="wuliuqi">

</head>

<body>
  <div class="container">

    <nav class="site-nav">
      <a href="https://wuliuqii.github.io/">Index</a>
    </nav>


<article class="post">
    <header class="post-header">
        <h1 class="post-title">Goleveldb源码分析（一）编码</h1>
        <time class="post-date"
            datetime="2022-03-31 08:30:25 &#43;0800">31 Mar 2022</time>
    </header>

    <p>研究一下基于Go语言的<a href="https://github.com/syndtr/goleveldb">Leveldb</a>的源码，参考作者的配套<a href="https://leveldb-handbook.readthedocs.io/zh/latest/rwopt.html">wiki</a>。</p>
<p>Leveldb的整体流程如下图所示
<img src="https://cdn.jsdelivr.net/gh/wuliuqii/pic@master/img/image.png" alt="image.png"></p>
<h2 id="基础">基础</h2>
<p>先从一些外围基础的概念开始看起。</p>
<h3 id="编码">编码</h3>
<p>Leveldb使用encoding/binary标准库对数据进行编解码，这里将详细介绍它的规则。</p>
<h4 id="大小端httpswwwwikiwandcomenendianness"><a href="https://www.wikiwand.com/en/Endianness">大小端</a></h4>
<p>字节序简单来说就是多字节对象在内存中的排列顺序，主要分为两种，大端序和小端序。</p>
<p>大端序，高位存在较大地址处。
<!-- raw HTML omitted -->
<!-- raw HTML omitted --></p>
<p>示例中，最高位字节是0x0A 存储在最低的内存地址处。下一个字节0x0B存在后面的地址处。正类似于十六进制字节从左到右的阅读顺序。</p>
<p>小端序，低位存在较大地址处。
<!-- raw HTML omitted -->
<!-- raw HTML omitted --></p>
<p>最低位字节是0x0D 存储在最低的内存地址处。后面字节依次存在后面的地址处。</p>
<p>在encoding/binary中定义了字节序的接口，同时也定义了大小端</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ByteOrder</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Uint16</span>([]<span style="color:#66d9ef">byte</span>) <span style="color:#66d9ef">uint16</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Uint32</span>([]<span style="color:#66d9ef">byte</span>) <span style="color:#66d9ef">uint32</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Uint64</span>([]<span style="color:#66d9ef">byte</span>) <span style="color:#66d9ef">uint64</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">PutUint16</span>([]<span style="color:#66d9ef">byte</span>, <span style="color:#66d9ef">uint16</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">PutUint32</span>([]<span style="color:#66d9ef">byte</span>, <span style="color:#66d9ef">uint32</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">PutUint64</span>([]<span style="color:#66d9ef">byte</span>, <span style="color:#66d9ef">uint64</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">String</span>() <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">littleEndian</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">LittleEndian</span> <span style="color:#a6e22e">littleEndian</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">bigEndian</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">BigEndian</span> <span style="color:#a6e22e">bigEndian</span>
</span></span></code></pre></div><p>看下编码的实例</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;encoding/binary&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">BigEndian</span>() { <span style="color:#75715e">// 大端序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 二进制形式：0000 0000 0000 0000 0001 0002 0003 0004
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">testInt</span> <span style="color:#66d9ef">int32</span> = <span style="color:#ae81ff">0x01020304</span> <span style="color:#75715e">// 十六进制表示
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%d use big endian: \n&#34;</span>, <span style="color:#a6e22e">testInt</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">testBytes</span> []<span style="color:#66d9ef">byte</span> = make([]<span style="color:#66d9ef">byte</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">binary</span>.<span style="color:#a6e22e">BigEndian</span>.<span style="color:#a6e22e">PutUint32</span>(<span style="color:#a6e22e">testBytes</span>, uint32(<span style="color:#a6e22e">testInt</span>)) <span style="color:#75715e">//大端序模式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;int32 to bytes:&#34;</span>, <span style="color:#a6e22e">testBytes</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">convInt</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">binary</span>.<span style="color:#a6e22e">BigEndian</span>.<span style="color:#a6e22e">Uint32</span>(<span style="color:#a6e22e">testBytes</span>) <span style="color:#75715e">//大端序模式的字节转为int32
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;bytes to int32: %d\n\n&#34;</span>, <span style="color:#a6e22e">convInt</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">LittleEndian</span>() { <span style="color:#75715e">// 小端序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//二进制形式： 0000 0000 0000 0000 0001 0002 0003 0004
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">testInt</span> <span style="color:#66d9ef">int32</span> = <span style="color:#ae81ff">0x01020304</span> <span style="color:#75715e">// 16进制
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%d use little endian: \n&#34;</span>, <span style="color:#a6e22e">testInt</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">testBytes</span> []<span style="color:#66d9ef">byte</span> = make([]<span style="color:#66d9ef">byte</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">binary</span>.<span style="color:#a6e22e">LittleEndian</span>.<span style="color:#a6e22e">PutUint32</span>(<span style="color:#a6e22e">testBytes</span>, uint32(<span style="color:#a6e22e">testInt</span>)) <span style="color:#75715e">//小端序模式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;int32 to bytes:&#34;</span>, <span style="color:#a6e22e">testBytes</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">convInt</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">binary</span>.<span style="color:#a6e22e">LittleEndian</span>.<span style="color:#a6e22e">Uint32</span>(<span style="color:#a6e22e">testBytes</span>) <span style="color:#75715e">//小端序模式的字节转换
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;bytes to int32: %d\n\n&#34;</span>, <span style="color:#a6e22e">convInt</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">BigEndian</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">LittleEndian</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// output：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 16909060 use big endian: 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// int32 to bytes: [1 2 3 4]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// bytes to int32: 16909060
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 16909060 use little endian: 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// int32 to bytes: [4 3 2 1]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// bytes to int32: 16909060
</span></span></span></code></pre></div><h3 id="varint">varint</h3>
<p>varint是一种使用一个或多个字节序列化整数的方法，会把整数编码为变长字节。对于32位整型数据经过varint编码后需要1-5个字节，小的数字使用1个byte，大的数字使用5个bytes。64位整型数据编码后占用1~10个字节。在实际场景中小数字的使用率远远多于大数字，因此通过varint编码对于大部分场景都可以起到很好的压缩效果。<br>
看下源码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">binary</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">PutUvarint</span>(<span style="color:#a6e22e">buf</span> []<span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">x</span> <span style="color:#66d9ef">uint64</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0x80</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 从低位往高位依此取7bit，标志位置为1，组成一个byte
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">buf</span>[<span style="color:#a6e22e">i</span>] = byte(<span style="color:#a6e22e">x</span>) | <span style="color:#ae81ff">0x80</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">x</span> <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">7</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 最后一个byte，标志位为0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">buf</span>[<span style="color:#a6e22e">i</span>] = byte(<span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 解码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Uvarint</span>(<span style="color:#a6e22e">buf</span> []<span style="color:#66d9ef">byte</span>) (<span style="color:#66d9ef">uint64</span>, <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#66d9ef">uint64</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> <span style="color:#66d9ef">uint</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">buf</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">MaxVarintLen64</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Catch byte reads past MaxVarintLen64.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">// See issue https://golang.org/issues/41185
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span>(<span style="color:#a6e22e">i</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#75715e">// overflow
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">b</span> &lt; <span style="color:#ae81ff">0x80</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">MaxVarintLen64</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">b</span> &gt; <span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span>(<span style="color:#a6e22e">i</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#75715e">// overflow
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 最后一个byte
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> | uint64(<span style="color:#a6e22e">b</span>)<span style="color:#f92672">&lt;&lt;</span><span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">i</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 取当前byte的后7bit
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">x</span> <span style="color:#f92672">|=</span> uint64(<span style="color:#a6e22e">b</span><span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0x7f</span>) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#a6e22e">s</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">s</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">7</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>看个实例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">buf</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">binary</span>.<span style="color:#a6e22e">MaxVarintLen64</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int64</span> = <span style="color:#ae81ff">123456</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 二进制形式：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 0001 1110 0010 0100 0000
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 按照7bit一组：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 0000111 1000100 1000000
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 从低位往高位以此取7bit，重新编码，注意是反转排序，全0的bit舍弃
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 1000000 1000100 0000111
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 再加上标志位，每7bit组成一个字节，如果后面还有字节，则标志位为1，反之为0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// varint编码：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 11000000 11000100 00000111
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 0xc0		0xc4	 0x07
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">binary</span>.<span style="color:#a6e22e">PutVarint</span>(<span style="color:#a6e22e">buf</span>, <span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%b %x\n&#34;</span>, <span style="color:#a6e22e">buf</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">binary</span>.<span style="color:#a6e22e">Uvarint</span>(<span style="color:#a6e22e">buf</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%b\n&#34;</span>, <span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// output：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// [11000000 11000100 111 0 0 0 0 0 0 0]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// c0c40700000000000000
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 11110001001000000
</span></span></span></code></pre></div><h2 id="batch">Batch</h2>
<p>Leveldb对外提供的写入接口有：（1）Put（2）Delete两种。这两种本质对应同一种操作，Delete操作同样会被转换成一个value为空的Put操作。</p>
<p>无论是Put/Del操作，还是批量操作，底层都会为这些操作创建一个batch实例作为一个数据库操作的最小执行单元。因此首先介绍一下batch的组织结构。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wuliuqii/pic@master/img/batch.jpeg" alt="img"></p>
<p>在batch中，每一条数据项都按照上图格式进行编码。每条数据项编码后的第一位是这条数据项的类型（更新还是删除），之后是数据项key的长度，数据项key的内容；若该数据项不是删除操作，则再加上value的长度，value的内容。</p>
<p>batch中会维护一个size值，用于表示其中包含的数据量的大小。该size值为所有数据项key与value长度的累加，以及每条数据项额外的8个字节。这8个字节用于存储一条数据项额外的一些信息。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 用来进行批处理操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Batch</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// +------+------------+-----+--------------+-------+
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// | type | key length | key | value length | value |
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// +------+------------+-----+--------------+-------+
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">data</span>  []<span style="color:#66d9ef">byte</span>       <span style="color:#75715e">// 数据项编码形式如上所示，value和value length只有在Put操作的时候才有
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">index</span> []<span style="color:#a6e22e">batchIndex</span> <span style="color:#75715e">// data 的元信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// internalLen is sums of key/value pair length plus 8-bytes internal key.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">internalLen</span> <span style="color:#66d9ef">int</span> <span style="color:#75715e">// (key length+value length+8)*数据项个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>写操作（1）Put（2）Delete底层都是通过appendRec实现的</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Batch</span>) <span style="color:#a6e22e">Put</span>(<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span> []<span style="color:#66d9ef">byte</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">appendRec</span>(<span style="color:#a6e22e">keyTypeVal</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Batch</span>) <span style="color:#a6e22e">Delete</span>(<span style="color:#a6e22e">key</span> []<span style="color:#66d9ef">byte</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">appendRec</span>(<span style="color:#a6e22e">keyTypeDel</span>, <span style="color:#a6e22e">key</span>, <span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 不使用slice默认的扩容策略
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Batch</span>) <span style="color:#a6e22e">grow</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">o</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">data</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> cap(<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">data</span>)<span style="color:#f92672">-</span><span style="color:#a6e22e">o</span> &lt; <span style="color:#a6e22e">n</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 容量不够了，需要扩容
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 默认扩大到现在的数据项+n+数据项/系数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 默认的系数为1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">div</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">index</span>) &gt; <span style="color:#a6e22e">batchGrowRec</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 数据项超过3000，则系数变为数据项/3000
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">div</span> = len(<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">index</span>) <span style="color:#f92672">/</span> <span style="color:#a6e22e">batchGrowRec</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">ndata</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">o</span>, <span style="color:#a6e22e">o</span><span style="color:#f92672">+</span><span style="color:#a6e22e">n</span><span style="color:#f92672">+</span><span style="color:#a6e22e">o</span><span style="color:#f92672">/</span><span style="color:#a6e22e">div</span>)
</span></span><span style="display:flex;"><span>		copy(<span style="color:#a6e22e">ndata</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">data</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">data</span> = <span style="color:#a6e22e">ndata</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// +------+------------+-----+--------------+-------+
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// | type | key length | key | value length | value |
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// +------+------------+-----+--------------+-------+
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Batch</span>) <span style="color:#a6e22e">appendRec</span>(<span style="color:#a6e22e">kt</span> <span style="color:#a6e22e">keyType</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span> []<span style="color:#66d9ef">byte</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// (type+key+key length)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">binary</span>.<span style="color:#a6e22e">MaxVarintLen32</span> <span style="color:#f92672">+</span> len(<span style="color:#a6e22e">key</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">kt</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">keyTypeVal</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Put操作还要加上 value+value length
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">n</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">binary</span>.<span style="color:#a6e22e">MaxVarintLen32</span> <span style="color:#f92672">+</span> len(<span style="color:#a6e22e">value</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 确保容量足够
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">grow</span>(<span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">index</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">batchIndex</span>{<span style="color:#a6e22e">keyType</span>: <span style="color:#a6e22e">kt</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">o</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">data</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">data</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">data</span>[:<span style="color:#a6e22e">o</span><span style="color:#f92672">+</span><span style="color:#a6e22e">n</span>]
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// type
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">data</span>[<span style="color:#a6e22e">o</span>] = byte(<span style="color:#a6e22e">kt</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">o</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// key length
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">o</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">binary</span>.<span style="color:#a6e22e">PutUvarint</span>(<span style="color:#a6e22e">data</span>[<span style="color:#a6e22e">o</span>:], uint64(len(<span style="color:#a6e22e">key</span>)))
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">index</span>.<span style="color:#a6e22e">keyPos</span> = <span style="color:#a6e22e">o</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">index</span>.<span style="color:#a6e22e">keyLen</span> = len(<span style="color:#a6e22e">key</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// key
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">o</span> <span style="color:#f92672">+=</span> copy(<span style="color:#a6e22e">data</span>[<span style="color:#a6e22e">o</span>:], <span style="color:#a6e22e">key</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">kt</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">keyTypeVal</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// value length
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">o</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">binary</span>.<span style="color:#a6e22e">PutUvarint</span>(<span style="color:#a6e22e">data</span>[<span style="color:#a6e22e">o</span>:], uint64(len(<span style="color:#a6e22e">value</span>)))
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">index</span>.<span style="color:#a6e22e">valuePos</span> = <span style="color:#a6e22e">o</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">index</span>.<span style="color:#a6e22e">valueLen</span> = len(<span style="color:#a6e22e">value</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">o</span> <span style="color:#f92672">+=</span> copy(<span style="color:#a6e22e">data</span>[<span style="color:#a6e22e">o</span>:], <span style="color:#a6e22e">value</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">data</span> = <span style="color:#a6e22e">data</span>[:<span style="color:#a6e22e">o</span>]
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">index</span> = append(<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">index</span>, <span style="color:#a6e22e">index</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">internalLen</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">index</span>.<span style="color:#a6e22e">keyLen</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">index</span>.<span style="color:#a6e22e">valueLen</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>

</article>

<footer class="site-footer">
    <span itemscope itemtype="http://schema.org/Person">
        <link itemprop="url" href="https://wuliuqii.github.io/">
        <span itemprop="name"></span>

        <br>

        

        

        
    </span>


    <br><br>

    <div style="text-align:center">
        <small>
            <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img
                    alt="Creative Commons License" style="border-width:0"
                    src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />Content of this site is
            licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons
                Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
        </small>
    </div>

    
</footer>
</div>

<script src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

</body>

</html>

<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\[\[', '\]\]']],
                processEscapes: true,
                processEnvironments: true,
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                TeX: {
                    equationNumbers: {autoNumber: "AMS"},
                    extensions: ["AMSmath.js", "AMSsymbols.js"]
                }
            }
        });

        MathJax.Hub.Queue(function () {
            
            
            
            var all = MathJax.Hub.getAllJax(), i;
            for (i = 0; i < all.length; i += 1) {
                all[i].SourceElement().parentNode.className += ' has-jax';
            }
        });
    </script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: #fbfbfb;
        border: inherit;
        color: #303030;
    }
</style>

