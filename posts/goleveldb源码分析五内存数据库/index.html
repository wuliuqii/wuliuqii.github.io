<!DOCTYPE html>
<html lang="zh-cn">

<head>
  <meta charset="utf-8">
  <meta name="generator" content="Hugo 0.96.0" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="">
  <meta property="og:url" content="https://wuliuqii.github.io/posts/goleveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%BA%94%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93/">

  <title>Goleveldb源码分析（五）内存数据库 - wuliuqi</title>
  <meta property="og:title" content="Goleveldb源码分析（五）内存数据库 - wuliuqi">
  <meta property="og:type" content="article">
  <meta name="description" content="">

  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Arvo:400,700">
  <link rel="stylesheet" href="/css/highlight.css">
  <link rel="stylesheet" href="/css/journal.css">
  <link href="/index.xml" rel="alternate" type="application/rss+xml" title="wuliuqi">

</head>

<body>
  <div class="container">

    <nav class="site-nav">
      <a href="https://wuliuqii.github.io/">Index</a>
    </nav>


<article class="post">
    <header class="post-header">
        <h1 class="post-title">Goleveldb源码分析（五）内存数据库</h1>
        <time class="post-date"
            datetime="2022-04-07 08:13:20 &#43;0800">07 Apr 2022</time>
    </header>

    <p>leveldb中内存数据库用来维护有序的key-value对，其底层是利用跳表实现，绝大多数操作（读／写）的时间复杂度均为O(log n)，有着与平衡树相媲美的操作效率，但是从实现的角度来说简单许多，因此在本文中将介绍一下内存数据库的实现细节。</p>
<h2 id="跳表">跳表</h2>
<p>关于跳表的详细介绍这里不再展开，想了解的可以去看论文<a href="https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf">Skip Lists: A Probabilistic Alternative to Balanced Trees</a>，这里只讲Leveldb中的实现。</p>
<h3 id="结构">结构</h3>
<p><img src="https://cdn.jsdelivr.net/gh/wuliuqii/pic@master/img/skiplist_arch.png" alt="img"></p>
<p>一个跳表的结构示意图如上所示。</p>
<p>跳表是按层建造的。底层是一个普通的<strong>有序</strong>链表。每个更高层都充当下面链表的<strong>快速通道</strong>，这里在层 $i$ 中的元素按某个固定的概率 $p$ (通常为0.5或0.25)出现在层 $i+1$ 中。平均起来，每个元素都在 $1/(1-p)$ 个列表中出现，而最高层的元素（通常是在跳跃列表前端的一个特殊的头元素）在 $O((log1/p)*n)$ 个列表中出现。</p>
<p>goleveldb中的跳表并没有单独抽象为一个结构体，而是嵌入到了DB结构中，同时它使用的实现方式是数组而非链表。这里的kvData数组存储key-value数据项，nodeData数组存储每个节点的链接信息，包括当前节点key-value值在kvData数组中的偏移量，层高，以及每层对应的下一个节点在nodeData中的索引值（下个节点的kv offset的索引值）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nKV</span>     = <span style="color:#66d9ef">iota</span> <span style="color:#75715e">// nodeData[0]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">nKey</span>           <span style="color:#75715e">// [1]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">nVal</span>           <span style="color:#75715e">// [2]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">nHeight</span>        <span style="color:#75715e">// [3]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">nNext</span>          <span style="color:#75715e">// [4]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 内存数据库
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">DB</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 用来比较key值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">cmp</span> <span style="color:#a6e22e">comparer</span>.<span style="color:#a6e22e">BasicComparer</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">rnd</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">rand</span>.<span style="color:#a6e22e">Rand</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mu</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">RWMutex</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 存储每一条数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// +------+--------+------+--------+-----+-------+---------+
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// | key1 | value1 | key2 | value2 | ... | key n | value n |
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// +------+--------+------+--------+-----+-------+---------+
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">kvData</span> []<span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 存储每个跳表节点的链接信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// +------------+-------------+---------------+--------+----------+-----+-----+---------+------------+-------------+---------------+--------+----------+-----+-----+---------+
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// | kv1 offset | key1 length | value1 length | height | 1st next | 2nd | ... | heights | kv2 offset | key2 length | value2 length | height | 1st next | 2nd | ... | heights |
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// +------------+-------------+---------------+--------+----------+-----+-----+---------+------------+-------------+---------------+--------+----------+-----+-----+---------+
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">nodeData</span> []<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 所有的操作共用，使用前需要持锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">prevNode</span> [<span style="color:#a6e22e">tMaxHeight</span>]<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 最大层高
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">maxHeight</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// key-value对个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// key-value的总大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">kvSize</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="查找">查找</h3>
<p><img src="https://cdn.jsdelivr.net/gh/wuliuqii/pic@master/img/skiplist_search.jpeg" alt="img"></p>
<p>查找操作是跳表其他操作的基础。</p>
<p>上图展示了查找一个值为17的链表节点的过程：</p>
<ul>
<li>首先根据跳表的高度选取最高层的头节点；</li>
<li>若跳表中的节点内容小于查找节点的内容，则取该层的下一个节点继续比较；</li>
<li>若跳表中的节点内容等于查找节点的内容，则直接返回；</li>
<li>若跳表中的节点内容大于查找节点的内容，且层高不为0，则降低层高，且从前一个节点开始，重新查找低一层中的节点信息；若层高为0，则返回当前节点，该节点的key大于所查找节点的key。</li>
</ul>
<p>综合来说，就是利用稀疏的高层节点，快速定位到所需要查找节点的大致位置，再利用密集的底层节点，具体比较节点的内容。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 找到第一个大于等于给定key的节点的索引
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">DB</span>) <span style="color:#a6e22e">findGE</span>(<span style="color:#a6e22e">key</span> []<span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">prev</span> <span style="color:#66d9ef">bool</span>) (<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">bool</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 头节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">node</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 最高层
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">h</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">maxHeight</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 当前层的下个节点索引
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">next</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">nodeData</span>[<span style="color:#a6e22e">node</span><span style="color:#f92672">+</span><span style="color:#a6e22e">nNext</span><span style="color:#f92672">+</span><span style="color:#a6e22e">h</span>]
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">cmp</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">next</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 当前层的下个节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">o</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">nodeData</span>[<span style="color:#a6e22e">next</span>]
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 比较当下个节点的key和给定key的大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">// 1为大于，0为等于，-1小于
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">cmp</span> = <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">cmp</span>.<span style="color:#a6e22e">Compare</span>(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">kvData</span>[<span style="color:#a6e22e">o</span>:<span style="color:#a6e22e">o</span><span style="color:#f92672">+</span><span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">nodeData</span>[<span style="color:#a6e22e">next</span><span style="color:#f92672">+</span><span style="color:#a6e22e">nKey</span>]], <span style="color:#a6e22e">key</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">cmp</span> &lt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Keep searching in this list
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">// 在当前层继续搜索
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">node</span> = <span style="color:#a6e22e">next</span>
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 当前层节点以及大于等于给定key了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">prev</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">prevNode</span>[<span style="color:#a6e22e">h</span>] = <span style="color:#a6e22e">node</span>
</span></span><span style="display:flex;"><span>			} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">cmp</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// 等于
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">next</span>, <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">h</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// 大于
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">next</span>, <span style="color:#a6e22e">cmp</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 往下层搜索
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">h</span><span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="插入">插入</h3>
<p>插入操作借助于查找操作实现。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wuliuqii/pic@master/img/skiplist_insert.jpeg" alt="img"></p>
<ul>
<li>在查找的过程中，不断记录<strong>每一层</strong>的<strong>前任节点</strong>，如图中红色圆圈所表示的；</li>
<li>为新插入的节点随机产生层高（随机产生层高的算法较为简单，依赖最高层数和概率值p，可见下文中的代码实现）；</li>
<li>在合适的位置插入新节点（例如图中节点12与节点19之间），并依据查找时记录的前任节点信息，在每一层中，<strong>以链表插入</strong>的方式，将该节点插入到每一层的链接中。</li>
</ul>
<p><strong>链表插入</strong>指：将当前节点的Next值置为前任节点的Next值，将前任节点的Next值替换为当前节点。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">DB</span>) <span style="color:#a6e22e">randHeight</span>() (<span style="color:#a6e22e">h</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">branching</span> = <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">h</span> = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">h</span> &lt; <span style="color:#a6e22e">tMaxHeight</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">rnd</span>.<span style="color:#a6e22e">Int</span>()<span style="color:#f92672">%</span><span style="color:#a6e22e">branching</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// h层的概率为0.25^h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">h</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 插入节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">DB</span>) <span style="color:#a6e22e">Put</span>(<span style="color:#a6e22e">key</span> []<span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">value</span> []<span style="color:#66d9ef">byte</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">node</span>, <span style="color:#a6e22e">exact</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">findGE</span>(<span style="color:#a6e22e">key</span>, <span style="color:#66d9ef">true</span>); <span style="color:#a6e22e">exact</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 当前跳表中已有给定key的node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 覆盖掉原来的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">kvOffset</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">kvData</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">kvData</span> = append(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">kvData</span>, <span style="color:#a6e22e">key</span><span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">kvData</span> = append(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">kvData</span>, <span style="color:#a6e22e">value</span><span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">nodeData</span>[<span style="color:#a6e22e">node</span>] = <span style="color:#a6e22e">kvOffset</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">nodeData</span>[<span style="color:#a6e22e">node</span><span style="color:#f92672">+</span><span style="color:#a6e22e">nVal</span>]
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">nodeData</span>[<span style="color:#a6e22e">node</span><span style="color:#f92672">+</span><span style="color:#a6e22e">nVal</span>] = len(<span style="color:#a6e22e">value</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">kvSize</span> <span style="color:#f92672">+=</span> len(<span style="color:#a6e22e">value</span>) <span style="color:#f92672">-</span> <span style="color:#a6e22e">m</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 随机高度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">h</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">randHeight</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">h</span> &gt; <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">maxHeight</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">maxHeight</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">h</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 每层链表的初始前驱节点为头节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">prevNode</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">maxHeight</span> = <span style="color:#a6e22e">h</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 插入节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">kvOffset</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">kvData</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">kvData</span> = append(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">kvData</span>, <span style="color:#a6e22e">key</span><span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">kvData</span> = append(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">kvData</span>, <span style="color:#a6e22e">value</span><span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">node</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">nodeData</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">nodeData</span> = append(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">nodeData</span>, <span style="color:#a6e22e">kvOffset</span>, len(<span style="color:#a6e22e">key</span>), len(<span style="color:#a6e22e">value</span>), <span style="color:#a6e22e">h</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">prevNode</span>[:<span style="color:#a6e22e">h</span>] {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 更新每层的前后节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">nNext</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">i</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">nodeData</span> = append(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">nodeData</span>, <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">nodeData</span>[<span style="color:#a6e22e">m</span>])
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">nodeData</span>[<span style="color:#a6e22e">m</span>] = <span style="color:#a6e22e">node</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">kvSize</span> <span style="color:#f92672">+=</span> len(<span style="color:#a6e22e">key</span>) <span style="color:#f92672">+</span> len(<span style="color:#a6e22e">value</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">n</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="删除">删除</h3>
<p>跳表的删除操作较为简单，依赖查找过程找到该节点在整个跳表中的位置后，<strong>以链表删除</strong>的方式，在每一层中，删除该节点的信息。</p>
<p><strong>链表删除</strong>指：将前任节点的Next值替换为当前节点的Next值，并将当前节点所占的资源释放。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 删除节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">DB</span>) <span style="color:#a6e22e">Delete</span>(<span style="color:#a6e22e">key</span> []<span style="color:#66d9ef">byte</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">node</span>, <span style="color:#a6e22e">exact</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">findGE</span>(<span style="color:#a6e22e">key</span>, <span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">exact</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ErrNotFound</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 将前任节点的Next值替换为当前节点的Next值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 并将当前节点所占的资源释放
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">h</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">nodeData</span>[<span style="color:#a6e22e">node</span><span style="color:#f92672">+</span><span style="color:#a6e22e">nHeight</span>]
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">prevNode</span>[:<span style="color:#a6e22e">h</span>] {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">nNext</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">i</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">nodeData</span>[<span style="color:#a6e22e">m</span>] = <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">nodeData</span>[<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">nodeData</span>[<span style="color:#a6e22e">m</span>]<span style="color:#f92672">+</span><span style="color:#a6e22e">nNext</span><span style="color:#f92672">+</span><span style="color:#a6e22e">i</span>]
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">kvSize</span> <span style="color:#f92672">-=</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">nodeData</span>[<span style="color:#a6e22e">node</span><span style="color:#f92672">+</span><span style="color:#a6e22e">nKey</span>] <span style="color:#f92672">+</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">nodeData</span>[<span style="color:#a6e22e">node</span><span style="color:#f92672">+</span><span style="color:#a6e22e">nVal</span>]
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">n</span><span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>还有一些其他的操作，这里不再赘述，基本操作都以来上面的实现。</p>
<h2 id="键值">键值</h2>
<p>这里再介绍一下内存数据库中的键值编码和比较规则。</p>
<h3 id="键值编码">键值编码</h3>
<p>由于内存数据库本质是一个kv集合，且所有的数据项都是依据key值排序的，因此键值的编码规则尤为关键。</p>
<p>内存数据库中，key称为internalKey，其由三部分组成：</p>
<ul>
<li>用户定义的key：这个key值也就是原生的key值；</li>
<li>序列号：leveldb中，每一次写操作都有一个sequence number，标志着写入操作的先后顺序。由于在leveldb中，可能会有多条相同key的数据项同时存储在数据库中，因此需要有一个序列号来标识这些数据项的新旧情况。序列号最大的数据项为最新值；</li>
<li>类型：标志本条数据项的类型，为更新还是删除；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wuliuqii/pic@master/img/internalkey.jpeg" alt="img"></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 内存数据库键值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">internalKey</span> []<span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 编码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// +------+--------------------------+--------------+
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// | uKey | sequence number(7 bytes) | type(1 byte) |
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// +------+--------------------------+--------------+
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">makeInternalKey</span>(<span style="color:#a6e22e">dst</span>, <span style="color:#a6e22e">ukey</span> []<span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">seq</span> <span style="color:#66d9ef">uint64</span>, <span style="color:#a6e22e">kt</span> <span style="color:#a6e22e">keyType</span>) <span style="color:#a6e22e">internalKey</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">seq</span> &gt; <span style="color:#a6e22e">keyMaxSeq</span> {
</span></span><span style="display:flex;"><span>		panic(<span style="color:#e6db74">&#34;leveldb: invalid sequence number&#34;</span>)
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">kt</span> &gt; <span style="color:#a6e22e">keyTypeVal</span> {
</span></span><span style="display:flex;"><span>		panic(<span style="color:#e6db74">&#34;leveldb: invalid type&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">dst</span> = <span style="color:#a6e22e">ensureBuffer</span>(<span style="color:#a6e22e">dst</span>, len(<span style="color:#a6e22e">ukey</span>)<span style="color:#f92672">+</span><span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>	copy(<span style="color:#a6e22e">dst</span>, <span style="color:#a6e22e">ukey</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">binary</span>.<span style="color:#a6e22e">LittleEndian</span>.<span style="color:#a6e22e">PutUint64</span>(<span style="color:#a6e22e">dst</span>[len(<span style="color:#a6e22e">ukey</span>):], (<span style="color:#a6e22e">seq</span><span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">8</span>)|uint64(<span style="color:#a6e22e">kt</span>))
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">internalKey</span>(<span style="color:#a6e22e">dst</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 解码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">parseInternalKey</span>(<span style="color:#a6e22e">ik</span> []<span style="color:#66d9ef">byte</span>) (<span style="color:#a6e22e">ukey</span> []<span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">seq</span> <span style="color:#66d9ef">uint64</span>, <span style="color:#a6e22e">kt</span> <span style="color:#a6e22e">keyType</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">ik</span>) &lt; <span style="color:#ae81ff">8</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">newErrInternalKeyCorrupted</span>(<span style="color:#a6e22e">ik</span>, <span style="color:#e6db74">&#34;invalid length&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">num</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">binary</span>.<span style="color:#a6e22e">LittleEndian</span>.<span style="color:#a6e22e">Uint64</span>(<span style="color:#a6e22e">ik</span>[len(<span style="color:#a6e22e">ik</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">8</span>:])
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">seq</span>, <span style="color:#a6e22e">kt</span> = uint64(<span style="color:#a6e22e">num</span><span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">8</span>), <span style="color:#a6e22e">keyType</span>(<span style="color:#a6e22e">num</span><span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0xff</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">kt</span> &gt; <span style="color:#a6e22e">keyTypeVal</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">newErrInternalKeyCorrupted</span>(<span style="color:#a6e22e">ik</span>, <span style="color:#e6db74">&#34;invalid type&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ukey</span> = <span style="color:#a6e22e">ik</span>[:len(<span style="color:#a6e22e">ik</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">8</span>]
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="键值比较">键值比较</h3>
<p>内存数据库中所有的数据项都是按照键值比较规则进行排序的。这个比较规则可以由用户自己定制，也可以使用系统默认的。在这里介绍一下系统默认的比较规则。</p>
<p>默认的比较规则：</p>
<ul>
<li>首先按照字典序比较用户定义的key（ukey），若用户定义key值大，整个internalKey就大；</li>
<li>若用户定义的key相同，则序列号大的internalKey值就小；</li>
</ul>
<p>通过这样的比较规则，则所有的数据项首先按照用户key进行升序排列；当用户key一致时，按照序列号进行降序排列，这样可以保证首先读到序列号大的数据项。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">BasicComparer</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// a &lt; b 返回 -1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// a == b 返回 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// a &gt; b 返回 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">Compare</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> []<span style="color:#66d9ef">byte</span>) <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">bytesComparer</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">bytesComparer</span>) <span style="color:#a6e22e">Compare</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> []<span style="color:#66d9ef">byte</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Compare</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>

</article>

<footer class="site-footer">
    <span itemscope itemtype="http://schema.org/Person">
        <link itemprop="url" href="https://wuliuqii.github.io/">
        <span itemprop="name"></span>

        <br>

        

        

        
    </span>


    <br><br>

    <div style="text-align:center">
        <small>
            <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img
                    alt="Creative Commons License" style="border-width:0"
                    src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />Content of this site is
            licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons
                Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
        </small>
    </div>

    
</footer>
</div>

<script src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

</body>

</html>

<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\[\[', '\]\]']],
                processEscapes: true,
                processEnvironments: true,
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                TeX: {
                    equationNumbers: {autoNumber: "AMS"},
                    extensions: ["AMSmath.js", "AMSsymbols.js"]
                }
            }
        });

        MathJax.Hub.Queue(function () {
            
            
            
            var all = MathJax.Hub.getAllJax(), i;
            for (i = 0; i < all.length; i += 1) {
                all[i].SourceElement().parentNode.className += ' has-jax';
            }
        });
    </script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: #fbfbfb;
        border: inherit;
        color: #303030;
    }
</style>

