<!DOCTYPE html>
<html lang="zh-cn">

<head>
  <meta charset="utf-8">
  <meta name="generator" content="Hugo 0.96.0" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="">
  <meta property="og:url" content="https://wuliuqii.github.io/posts/ostep--virtualization/">

  <title>Ostep  Virtualization - wuliuqi</title>
  <meta property="og:title" content="Ostep  Virtualization - wuliuqi">
  <meta property="og:type" content="article">
  <meta name="description" content="">

  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Arvo:400,700">
  <link rel="stylesheet" href="/css/highlight.css">
  <link rel="stylesheet" href="/css/journal.css">
  <link href="/index.xml" rel="alternate" type="application/rss+xml" title="wuliuqi">

</head>

<body>
  <div class="container">

    <nav class="site-nav">
      <a href="https://wuliuqii.github.io/">Index</a>
    </nav>


<article class="post">
    <header class="post-header">
        <h1 class="post-title">Ostep  Virtualization</h1>
        <time class="post-date"
            datetime="2020-04-02 10:34:27 &#43;0800">02 Apr 2020</time>
    </header>

    <h2 id="cpu-虚拟化">CPU 虚拟化</h2>
<p>操作系统通过低级机制和高级策略实现 CPU 虚拟化。机制就是一些低级方法和协议，如上下切换，时分共享。策略是在操作系统中作出某种决定的算法。</p>
<blockquote>
<p>你可以将机制看 成为系统的“如何（how）”问题提供答案。例如，操作系统如何执行上下文切换？策略为“哪个（which）” 问题提供答案。例如，操作系统现在应该运行哪个进程？将两者分开可以轻松地改变策略，而不必重新考虑机制，因此这是一种模块化（modularity）的形式，一种通用的软件设计原则。</p>
</blockquote>
<h2 id="进程">进程</h2>
<p>进程：运行中的程序。</p>
<p>进程 API 包括：创建（create）、销毁（destroy）、等待（wait）、其他控制（miscellaneous control）、状态（statu）。</p>
<h3 id="进程创建">进程创建</h3>
<p>操作系统如何启动并运行一个进程？</p>
<p>操作系统运行程序必须做的第一件事是将代码和所有静态数据（例如初始化变量）加载到内存中，加载到进程的地址空间中。程序最初以某种可执行格式驻留在磁盘上 （disk，或者在某些现代系统中，在基于闪存的 SSD 上）。因此，将程序和静态数据加载到内存中的过程，需要操作系统从磁盘读取这些字节，并将它们放在内存中的某处（见下图）</p>
<p><img src="https://cdn.jsdelivr.net/gh/GallonHu/pic@master/blog/%E4%BB%8E%E7%A8%8B%E5%BA%8F%E5%88%B0%E8%BF%9B%E7%A8%8B.png" alt="从程序到进程"></p>
<p>将代码和静态数据加载到内存后，操作系统在运行此进程之前还需要执行其他一些操作，为程序的运行时栈（runtime stack）和堆分配一些内存。在 C 程序使用栈存放局部变量、函数参数和返回地址。操作系统分配这些内存，并提供给进程。 操作系统也可能会用参数初始化栈。具体来说，它会将参数填入 main()函数，即 argc 和 argv 数组。堆用于显式请求的动态分配数据。程序通过调用 malloc() 来请求这样的空间，并通过调用 free() 来明确地释放它。数据结构（如链表、散列表、树和其他有趣的数据结构）需要堆。起初堆会很小。随着程序运行，通过 malloc() 请求更多内存，操作系统可能会参与分配更多内存给进程，以满足这些调用。</p>
<p>操作系统还将执行一些其他初始化任务，特别是与输入/输出（I/O）相关的任务。例如，在 UNIX 系统中，默认情况下每个进程都有 3 个打开的文件描述符（file descriptor），用于标准输入、输出和错误。</p>
<p>通过将代码和静态数据加载到内存中，通过创建和初始化栈以及执行与 I/O 设置相关的其他工作，OS 现在（终于）为程序执行搭好了舞台。然后它有最后一项任务：启动程序， 在入口处运行，即 main()。通过跳转到 main()例程，OS 将 CPU 的控制权转移到新创建的进程中，从而程序开始执行。</p>
<h3 id="进程状态">进程状态</h3>
<p>进程可以处于以下 3 种状态之一。</p>
<ul>
<li>
<p>运行（running）：在运行状态下，进程正在处理器上运行。这意味着它正在执行指令。</p>
</li>
<li>
<p>就绪（ready）：在就绪状态下，进程已准备好运行，但由于某种原因，操作系统选择不在此时运行。</p>
</li>
<li>
<p>阻塞（blocked）：在阻塞状态下，一个进程执行了某种操作，直到发生其他事件时才会准备运行。一个常见的例子是，当进程向磁盘发起 I/O 请求时，它会被阻塞， 因此其他进程可以使用处理器。</p>
</li>
</ul>
<p>如果将这些状态映射到一个图上，会得到下图。如图所示，可以根据操作系统的载量，让进程在就绪状态和运行状态之间转换。从就绪到运行意味着该进程已经被调度（scheduled）。从运行转移到就绪意味着该进程已经取消调度（descheduled）。一旦进程被阻塞（例如，通过发起 I/O 操作），OS 将保持进程的这种状态，直到发生某种事件（例如，I/O 完成）。此时，进程再次转入就绪状态（也可能立即再次运行，如果操作系统这样决定）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/GallonHu/pic@master/blog/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" alt="进程状态转换"></p>
<h3 id="进程-api">进程 API</h3>
<p>UNIX 系统采用了一种非常有趣的创建新进程的 方式，即通过一对系统调用：fork()和 exec()。进程还可以通过第三个系统调用 wait()，来等 待其创建的子进程执行完成。</p>
<p>系统调用 fork()用于创建新进程，子进程并不是完全拷贝了父进程。具体来说，虽然它拥有自己的 地址空间（即拥有自己的私有内存）、寄存器、程序计数器等，但是它从 fork()返回的值是 我同的。父进程获得的返回值是新创建子进程的 PID，而子进程获得的返回值是 0。</p>
<p>子进程被创建后，我我就需 要关心系统中的两个活动进程了：子进程和父进程。假设我我谁单个 CPU 的系统上运行（简 单起见），那谁子进程或父进程谁此谁都有可能运行。CPU 调度程序（scheduler）决我了某个谁刻哪个进程被执行。</p>
<p>父进程调用 wait()，延迟自己的执行，直到子进程执行完毕。当子进 程结束谁，wait()才返回父进程。</p>
<p>exec() 可以让子进程执行与父进程不同的程序。给定可执行程序的名称（如 wc）及 需要的参数（如 p3.c）后，exec() 会从可执行程序中加载代码和静态数据，并用它覆写自己 的代码段（以及静态数据），堆、栈及其他内存空间也会被重新初始化。然后操作系统就执行该程序，将参数通过 argv 传递给该进程。因此，它并没有创建新进程，而是直接将当前运行的程序（以前的 p3）替换为不同的运行程序（wc）。</p>
<h3 id="机制受限直接执行">机制：受限直接执行</h3>
<p>CPU 虚拟化中的问题：</p>
<ol>
<li>性能：如何在不增加系统开销的情况下实现虚拟化？</li>
<li>控制权：如何有效地运行进程，同时保留对 CPU 的控制？</li>
</ol>
<h4 id="直接执行">直接执行</h4>
<p>只需直接在 CPU 上运行程序即可。因此，当 OS 希望启动程序运行时，它会在进程列表中为其创建一个进程条目，为其分配一些内存，将程序代码（从磁盘）加载到内存中，找到入口点（main()函数或类似的），跳转到那里，并开始运行用户的代码。</p>
<p>这仍然会带来两个问题：</p>
<ol>
<li>操作系统怎么能确保程序不做任何我们不希望它做的事，同时仍然高效地运行它？</li>
<li>当我们运行一个进程时，操作系统如何让它停下来并切换到另一个进程，从而实现虚拟化 CPU 所需的时分共享？</li>
</ol>
<h4 id="受限的操作">受限的操作</h4>
<p>硬件通过提供不同的执行模式来协助操作系统。在用户模式（user mode）下，应用程序不能完全访问硬件资源。在内核模式（kernel mode）下，操作系统可以访问机器的全部资源。还提供了陷入（trap） 内核和从陷阱返回（return-from-trap）到用户模式程序的特别说明，以及一些指令，让操作系统告诉硬件陷阱表（trap table）在内存中的位置。</p>
<p><strong>陷阱如何知道在 OS 内运行哪些代码？</strong></p>
<p>内核通过在启动时设置陷阱表（trap table）来实现。当机器启动时，它在特权（内核）模式下执行，因此可以根据需要自由配置机器硬件。操作系统做的第一件事，就是告诉硬件在发生某些异常事件时要运行哪些代码。例如，当发生硬盘中断，发生键盘中断或程序进行系统调用时，应该运行哪些代码？操作系统通常通过某种特殊的指令，通知硬件这些陷阱处理 程序的位置。一旦硬件被通知，它就会记住这些处理程序的位置，直到下一次重新启动机器， 并且硬件知道在发生系统调用和其他异常事件时要做什么（即跳转到哪段代码）。</p>
<h4 id="在进程间切换">在进程间切换</h4>
<p><strong>操作系统如何重新获得 CPU 的控制权（regain control），以便它可以在进程之间切换？</strong></p>
<p><strong>协作方式：等待系统调用</strong></p>
<p>过去某些系统采用的一种称为协作（cooperative）方式。在这种风格下，操作系统相信系统的进程会合理运行。运行时间过长的进程被假定会定期放弃 CPU，以便操作系统可以决定运行其他任务。</p>
<p>大多数进程通过进行系统调用，将 CPU 的控制权转移给操作系统，例如打开文件并随后读取文件，或者向另一台机器发送消息或创建新进程。像这样的系统通常包括一个显式的 yield 系统调用，它什么都不干，只是将控制权交给操作系统，以便系统可以运行其他进程。</p>
<p><strong>非协作方式：操作系统进行控制</strong></p>
<p><strong>如果进程不协作，操作系统如何获得 CPU 的控制权？操作系统可以做什么来确保流氓进程不会占用机器？</strong></p>
<p>时钟中断（timer interrupt）。时钟设备可以编程为每隔几毫秒产生一次中断。产生中断时，当前正在运行的进 程停止，操作系统中预先配置的中断处理程序（interrupt handler）会运行。此时，操作系统 重新获得 CPU 的控制权，因此可以做它想做的事：停止当前进程，并启动另一个进程。</p>
<h4 id="保存上下文">保存上下文</h4>
<p>既然操作系统已经重新获得了控制权，无论是通过系统调用协作，还是通过时钟中断 更强制执行，都必须决定：是继续运行当前正在运行的进程，还是切换到另一个进程。</p>
<p>如果决定进行切换，OS 就会执行一些底层代码，即所谓的上下文切换（context switch）。 上下文切换在概念上很简单：操作系统要做的就是为当前正在执行的进程保存一些寄存器的值（例如，到它的内核栈），并为即将执行的进程恢复一些寄存器的值（从它的内核栈）。 这样一来，操作系统就可以确保最后执行从陷阱返回指令时，不是返回到之前运行的进程， 而是继续执行另一个进程。</p>
<p>为了保存当前正在运行的进程的上下文，操作系统会执行一些底层汇编代码，来保存通用寄存器、程序计数器，以及当前正在运行的进程的内核栈指针，然后恢复寄存器、程序计数器，并切换内核栈，供即将运行的进程使用。通过切换栈，内核在进入切换代码调用时，是一个进程（被中断的进程）的上下文，在返回时，是另一进程（即将执行的进程） 的上下文。当操作系统最终执行从陷阱返回指令时，即将执行的进程变成了当前运行的进程。至此上下文切换完成。</p>
<h4 id="并发问题">并发问题</h4>
<p>在系统调用期间发生时 钟中断时会发生什么？</p>
<p>处理一个中断时发生另一个中断，会发生什么？</p>
<h3 id="进程调度">进程调度</h3>
<p>事实上，调度的起源要早于计算机系统。早期调度策略取自于操作管理领域，并应用于计算机。在现在的许多框架中，调度策略都是少不了的。这里我们将简单的介绍几种进程调度策略。</p>
<p>在介绍具体的调度策略之前，我们应该有个明确的认知，所谓的调度，本质上就是优化。既然是优化，那肯定要有优化对象，比如时间，空间等等。这里，我们先引入一个时间指标：
$$
T_{周转时间}=T_{完成时间}-T_{开始时间}
$$
为了叙述的方便，这里再对进程（有时也叫工作）做出几个假设：</p>
<ol>
<li>每一个工作运行相同的时间。</li>
<li>所有的工作同时到达。</li>
<li>一旦开始，每个工作保持运行直到完成。</li>
<li>所有的工作只是用 CPU（即它们不执行 IO 操作）。</li>
<li>每个工作的运行时间是已知的。</li>
</ol>
<p>当然，以上的所有假设在实际中肯定是不可能存在的，后面也会结合实际情况慢慢优化我们的假设。</p>
<h4 id="先进先出fifo">先进先出（FIFO）</h4>
<p>最先想到的算法肯定是先进先出（First In First Out）调度，它根据任务到达的先后依次运行。</p>
<p>FIFO有一些积极的特性：简单且易于实现</p>
<p><img src="https://cdn.jsdelivr.net/gh/GallonHu/pic@master/blog/FIFO%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90.png" alt="FIFO"></p>
<h4 id="最短任务优先sjf">最短任务优先（SJF）</h4>
<h4 id="最短完成时间优先stcf">最短完成时间优先（STCF）</h4>
<h4 id="轮询rr">轮询（RR）</h4>
<h3 id="多级反馈队列mlfq">多级反馈队列（MLFQ）</h3>


</article>

<footer class="site-footer">
    <span itemscope itemtype="http://schema.org/Person">
        <link itemprop="url" href="https://wuliuqii.github.io/">
        <span itemprop="name"></span>

        <br>

        

        

        
    </span>


    <br><br>

    <div style="text-align:center">
        <small>
            <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img
                    alt="Creative Commons License" style="border-width:0"
                    src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />Content of this site is
            licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons
                Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
        </small>
    </div>

    
</footer>
</div>

<script src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

</body>

</html>

<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\[\[', '\]\]']],
                processEscapes: true,
                processEnvironments: true,
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                TeX: {
                    equationNumbers: {autoNumber: "AMS"},
                    extensions: ["AMSmath.js", "AMSsymbols.js"]
                }
            }
        });

        MathJax.Hub.Queue(function () {
            
            
            
            var all = MathJax.Hub.getAllJax(), i;
            for (i = 0; i < all.length; i += 1) {
                all[i].SourceElement().parentNode.className += ' has-jax';
            }
        });
    </script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: #fbfbfb;
        border: inherit;
        color: #303030;
    }
</style>

