<!DOCTYPE html>
<html lang="zh-cn">

<head>
  <meta charset="utf-8">
  <meta name="generator" content="Hugo 0.98.0" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="">
  <meta property="og:url" content="https://wuliuqii.github.io/posts/goleveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/">

  <title>Goleveldb源码分析（三）布隆过滤器 - wuliuqi</title>
  <meta property="og:title" content="Goleveldb源码分析（三）布隆过滤器 - wuliuqi">
  <meta property="og:type" content="article">
  <meta name="description" content="">

  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Arvo:400,700">
  <link rel="stylesheet" href="/css/highlight.css">
  <link rel="stylesheet" href="/css/journal.css">
  <link href="/index.xml" rel="alternate" type="application/rss+xml" title="wuliuqi">

</head>

<body>
  <div class="container">

    <nav class="site-nav">
      <a href="https://wuliuqii.github.io/">Index</a>
    </nav>


<article class="post">
    <header class="post-header">
        <h1 class="post-title">Goleveldb源码分析（三）布隆过滤器</h1>
        <time class="post-date"
            datetime="2022-04-01 08:19:43 &#43;0800">01 Apr 2022</time>
    </header>

    <p>布隆过滤器是一种空间效率很高的随机数据结构，它利用位数组很简洁地表示一个集合，并能判断一个元素是否属于这个集合。布隆过滤器的这种高效是有一定代价的：在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合（false positive）。因此，布隆过滤器不适合那些<strong>零错误</strong>的应用场合。而在能容忍低错误率的应用场合下，布隆过滤器通过极少的错误换取了存储空间的极大节省。</p>
<p>Leveldb中利用布隆过滤器判断指定的key值是否存在于sstable中，若过滤器表示不存在，则该key一定不存在，由此加快了查找的效率。</p>
<h2 id="结构">结构</h2>
<p>布隆过滤器底层是一个位数组，初始时每一位都是0</p>
<p><img src="https://cdn.jsdelivr.net/gh/wuliuqii/pic@master/img/bloom1.jpg" alt="img"></p>
<p>当插入值x后，分别利用k个哈希函数（图中为3）利用x的值进行散列，并将散列得到的值与布隆过滤器的容量进行取余，将取余结果所代表的那一位值置为1。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wuliuqii/pic@master/img/bloom2.jpg" alt="img"></p>
<p>一次查找过程与一次插入过程类似，同样利用k个哈希函数对所需要查找的值进行散列，只有散列得到的每一个位的值均为1，才表示该值“<strong>有可能</strong>”真正存在；反之若有任意一位的值为0，则表示该值一定不存在。例如y1一定不存在；而y2可能存在。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wuliuqii/pic@master/img/bloom3.jpg" alt="img"></p>
<h2 id="数学结论1">数学结论<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></h2>
<p>首先，与布隆过滤器准确率有关的参数有：</p>
<ul>
<li>哈希函数的个数k；</li>
<li>布隆过滤器位数组的容量m;</li>
<li>布隆过滤器插入的数据数量n。</li>
</ul>
<p>主要的数学结论有：</p>
<ol>
<li>为了获得最优的准确率，当$k = ln2 * (m/n$)时，布隆过滤器获得最优的准确性；</li>
<li>在哈希函数的个数取到最优时，要让错误率不超过є，m至少需要取到最小值的1.44倍。</li>
</ol>
<h2 id="实现">实现</h2>
<p>goleveldb中，布隆过滤器的定义只是一个int数字</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">bloomFilter</span> <span style="color:#66d9ef">int</span>
</span></span></code></pre></div><p>创建一个布隆过滤器时，只需要指定为每个key分配的位数即可，如结论2所示，只要该值（m/n）大于1.44即可，一般可以取10。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewBloomFilter</span>(<span style="color:#a6e22e">bitsPerKey</span> <span style="color:#66d9ef">int</span>) <span style="color:#a6e22e">Filter</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">bloomFilter</span>(<span style="color:#a6e22e">bitsPerKey</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>创建一个Generator, 这一步中需要指定哈希函数的个数k，可以看到$k = f * ln2$，而$f = m/n$，即数学结论1。</p>
<p>返回的Generator中可以添加新的key信息，调用Generate函数时，将所有的key构建成一个位数组写在指定的位置。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">bloomFilterGenerator</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>   <span style="color:#75715e">// 插入的数据量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">k</span> <span style="color:#66d9ef">uint8</span> <span style="color:#75715e">// hash 函数的个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">keyHashes</span> []<span style="color:#66d9ef">uint32</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">f</span> <span style="color:#a6e22e">bloomFilter</span>) <span style="color:#a6e22e">NewGenerator</span>() <span style="color:#a6e22e">FilterGenerator</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Round down to reduce probing cost a little bit.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">k</span> <span style="color:#f92672">:=</span> uint8(<span style="color:#a6e22e">f</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">69</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">100</span>) <span style="color:#75715e">// 0.69 =~ ln(2)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">k</span> &lt; <span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">k</span> = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">k</span> &gt; <span style="color:#ae81ff">30</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">k</span> = <span style="color:#ae81ff">30</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">bloomFilterGenerator</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">n</span>: int(<span style="color:#a6e22e">f</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">k</span>: <span style="color:#a6e22e">k</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Generator主要有两个函数：</p>
<ol>
<li>Add</li>
<li>Generate</li>
</ol>
<p>Add函数中，只是简单地将key的哈希散列值存储在一个整型数组中</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">g</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">bloomFilterGenerator</span>) <span style="color:#a6e22e">Add</span>(<span style="color:#a6e22e">key</span> []<span style="color:#66d9ef">byte</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Use double-hashing to generate a sequence of hash values.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// See analysis in [Kirsch,Mitzenmacher 2006].
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">keyHashes</span> = append(<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">keyHashes</span>, <span style="color:#a6e22e">bloomHash</span>(<span style="color:#a6e22e">key</span>))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Generate函数中，将之前一段时间内所有添加的key信息用来构建一个位数组，该位数组中包含了所有key的存在信息。</p>
<p>位数组的大小为用户指定的每个key所分配的位数乘以 key的个数。</p>
<p>位数组的最末尾用来存储k的大小。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">g</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">bloomFilterGenerator</span>) <span style="color:#a6e22e">Generate</span>(<span style="color:#a6e22e">b</span> <span style="color:#a6e22e">Buffer</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Compute bloom filter size (in both bits and bytes)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">nBits</span> <span style="color:#f92672">:=</span> uint32(len(<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">keyHashes</span>) <span style="color:#f92672">*</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// For small n, we can see a very high false positive rate.  Fix it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// by enforcing a minimum bloom filter length.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// nBits太小，容错率大大降低
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">nBits</span> &lt; <span style="color:#ae81ff">64</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">nBits</span> = <span style="color:#ae81ff">64</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 向上取整
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">nBytes</span> <span style="color:#f92672">:=</span> (<span style="color:#a6e22e">nBits</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">7</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nBits</span> = <span style="color:#a6e22e">nBytes</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">dest</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Alloc</span>(int(<span style="color:#a6e22e">nBytes</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 最后一个byte放k
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">dest</span>[<span style="color:#a6e22e">nBytes</span>] = <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">k</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">kh</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">keyHashes</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">delta</span> <span style="color:#f92672">:=</span> (<span style="color:#a6e22e">kh</span> <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">17</span>) | (<span style="color:#a6e22e">kh</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">15</span>) <span style="color:#75715e">// Rotate right 17 bits
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> uint8(<span style="color:#ae81ff">0</span>); <span style="color:#a6e22e">j</span> &lt; <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">k</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">bitpos</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">kh</span> <span style="color:#f92672">%</span> <span style="color:#a6e22e">nBits</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">dest</span>[<span style="color:#a6e22e">bitpos</span><span style="color:#f92672">/</span><span style="color:#ae81ff">8</span>] <span style="color:#f92672">|=</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#a6e22e">bitpos</span> <span style="color:#f92672">%</span> <span style="color:#ae81ff">8</span>))
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">kh</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">delta</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">keyHashes</span> = <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">keyHashes</span>[:<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Contain函数用来判断指定的key是否存在。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">f</span> <span style="color:#a6e22e">bloomFilter</span>) <span style="color:#a6e22e">Contains</span>(<span style="color:#a6e22e">filter</span>, <span style="color:#a6e22e">key</span> []<span style="color:#66d9ef">byte</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">nBytes</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">filter</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">nBytes</span> &lt; <span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">nBits</span> <span style="color:#f92672">:=</span> uint32(<span style="color:#a6e22e">nBytes</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Use the encoded k so that we can read filters generated by
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// bloom filters created using different parameters.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">k</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">filter</span>[<span style="color:#a6e22e">nBytes</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">k</span> &gt; <span style="color:#ae81ff">30</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Reserved for potentially new encodings for short bloom filters.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// Consider it a match.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">kh</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">bloomHash</span>(<span style="color:#a6e22e">key</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">delta</span> <span style="color:#f92672">:=</span> (<span style="color:#a6e22e">kh</span> <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">17</span>) | (<span style="color:#a6e22e">kh</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">15</span>) <span style="color:#75715e">// Rotate right 17 bits
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> uint8(<span style="color:#ae81ff">0</span>); <span style="color:#a6e22e">j</span> &lt; <span style="color:#a6e22e">k</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">bitpos</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">kh</span> <span style="color:#f92672">%</span> <span style="color:#a6e22e">nBits</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (uint32(<span style="color:#a6e22e">filter</span>[<span style="color:#a6e22e">bitpos</span><span style="color:#f92672">/</span><span style="color:#ae81ff">8</span>]) <span style="color:#f92672">&amp;</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#a6e22e">bitpos</span> <span style="color:#f92672">%</span> <span style="color:#ae81ff">8</span>))) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">kh</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">delta</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>布隆过滤器整体来说比较简单，主要就是数学结论，但咱们只看实现。外围的一些比较重要的概念咱们算是看完了，接下来就要看数据库的核心实现了。</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p><a href="http://blog.csdn.net/jiaomeng/article/details/1495500">http://blog.csdn.net/jiaomeng/article/details/1495500</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>


</article>

<footer class="site-footer">
    <span itemscope itemtype="http://schema.org/Person">
        <link itemprop="url" href="https://wuliuqii.github.io/">
        <span itemprop="name"></span>

        <br>

        

        

        
    </span>


    <br><br>

    <div style="text-align:center">
        <small>
            <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img
                    alt="Creative Commons License" style="border-width:0"
                    src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />Content of this site is
            licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons
                Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
        </small>
    </div>

    
</footer>
</div>

<script src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

</body>

</html>

<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\[\[', '\]\]']],
                processEscapes: true,
                processEnvironments: true,
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                TeX: {
                    equationNumbers: {autoNumber: "AMS"},
                    extensions: ["AMSmath.js", "AMSsymbols.js"]
                }
            }
        });

        MathJax.Hub.Queue(function () {
            
            
            
            var all = MathJax.Hub.getAllJax(), i;
            for (i = 0; i < all.length; i += 1) {
                all[i].SourceElement().parentNode.className += ' has-jax';
            }
        });
    </script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: #fbfbfb;
        border: inherit;
        color: #303030;
    }
</style>

