---
title: "6.824 lab1"
date: 2021-05-09T20:30:53+08:00
categories: 6.824
tags: [Golang, MapReduce]
draft: false
---

# 6.824 Lab 1

课程主页: https://pdos.csail.mit.edu/6.824/schedule.html

Lab1: https://pdos.csail.mit.edu/6.824/labs/lab-mr.html

论文: http://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf

## 要求

lab 1 主要是实现一个简易版 MapReduce 系统，主要有两部分：

1.  worker：map、reduce 函数执行 ，文件读写处理
2.  coordinate：任务调度
3.  测试用例会有任务超时和 crash 的情况，需要有容错机制

整个流程大概可以简化成如下几步：

1.  启动 coordinate 进程，监听 worker 请求
2.  启动单个或多个 worker 进程，worker 向 coordinate 请求任务
3.  coordinate 处理 worker 的任务请求，步骤如下：
    -   判断 map 任务是否全部完成
    -   若未完成，挑选一个未完成的 map 任务，并将该任务状态设置为 assigned；否则判断 reduce 任务是否全部完成
    -   若未完成，挑选一个未完成的 reduce 任务，并将该任务状态设置为 assigned
4.  worker 收到任务后，根据任务类型执行对应的函数（map、reduce、wait）
5.  worker 完成任务后，向 coordinate 发送任务已完成
6.  coordinate 将相应完成的任务的状态标记为 finished
7.  重复 1-6 直至所有任务完成

## worker

worker 不断向 coordinate 请求任务，根据返回的任务进行处理，主体程序如下：

```go
func Worker(mapf func(string, string) []KeyValue,
	reducef func(string, []string) string) {
	for {
		args := RequestArgs{MessageType: RequestTask}
		reply := RequestReply{}
		err := call("Coordinator.WorkerCallHandler", &args, &reply)
		if !err {
			log.Fatalf("rpc call err: %v", err)
		}

		switch reply.Task.Type {
		case Map:
			doMap()
		case Reduce:
			doReduce()
		case Wait:
			doWait()
		}
	}
}
```

其中 Request 结构体如下：

```go
type RequestArgs struct {
	MessageType int // RequestTask, FinishTask
	Task        Task
}

type RequestReply struct {
	Task    Task
	NReduce int
}
```

这里有几个点需要注意：

1.  worker 读写文件都是在本地
2.  map 处理完的中间结果需要用文件保存在本地
3.  map 中保存的临时中间文件在完成后返回给 coordinate 并修改文件名

## coordinate

coordinate 需要处理所有 worker 的请求，分配 map 和 reduce 任务，并重新安排失败的任务。因此，我们的 coordinator 结构体如下

```go
type Task struct {
	Index       int
	Uid         string // for temp intermediate filename
	Type        int // map, reduce, wait
	Status      int // unassigned, assigned, finished
	MapFile     string
	ReduceFiles []string
}

type Coordinator struct {
	mapTasks          []*Task
	reduceTasks       []*Task
	mapFinishedCnt    int
	reduceFinishedCnt int
	rw                sync.RWMutex
}
```

在实现的时候，这里做了一些简化：

1.  使用数组保存 map 或 reduce 任务，这样的处理，便于后续的任务的处理
2.  coordinate 初始化后，mapTasks 和 reduceTasks 数组长度固定，任务分配和完成只是简单的修改状态
3.  使用一个全局读写锁处理并发读写
4.  容错处理，在给定时间内任务未完成，将该任务状态修改为 unassigned，重新分配

## 运行结果

使用 mac 系统，代码写完后运行测试脚本，发现有几个坑。

1.  timeout

mac 系统默认没有 timeout 命令，需手动安装

```shell
brew install coreutils
```

2.  wait -n

mac 自动 bash 版本过低，需要升级 bash 版本

```shell
brew install bash
```

最后，附上运行结果

![image-20210530002821636](https://cdn.jsdelivr.net/gh/wuliuqii/pic@master/blog/image-20210530002821636.png)