---
title: "6.824 Lab2A"
date: 2022-01-10T23:37:13+08:00
categories: 6.824
tags: [Golang, Raft]
draft: true
---

# 6.824 Lab 2A

课程主页: https://pdos.csail.mit.edu/6.824/schedule.html

Lab2: https://pdos.csail.mit.edu/6.824/labs/lab-raft.html

论文: https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf

## 要求

raft 算法通过领导人机制，将一致性问题分解成了三个相对独立的子问题：

1.   领导选举
2.   日志复制
3.   安全性

Lab 2A 主要的任务就是实现 raft 的选主算法。

## raft 基础

raft 集群中的服务器节点都处于一下三个状态之一：领导人、跟随者和候选人。正常的情况中，系统中应该只有一个领导人，并且其他节点都是跟随者。跟随者被动响应来着领导人或候选人的请求。领导人和客户端交互。候选人在选举新领导人的时候出现。

![图 4 ](https://github.com/maemual/raft-zh_cn/raw/master/images/raft-%E5%9B%BE4.png)

raft 把时间分割成任意长度的**任期**。任期用连续的整数标记。每一段任期从一次**选举**开始，一个或者多个候选人尝试成为领导人。如果一个候选人赢得选举，然后他就在接下来的任期内充当领导人的职责。在某些情况下，一次选举过程会造成选票的瓜分。在这种情况下，这一任期会以没有领导人结束；一个新的任期（和一次新的选举）会很快重新开始。raft 保证了在一个给定的任期内，最多只有一个领导人。

![图 5](https://github.com/maemual/raft-zh_cn/raw/master/images/raft-%E5%9B%BE5.png)

## 实现

 2A 中，只关注选举的过程，所以我们目前仅关注部分参数以及选举和心跳流程。

```go
type Raft struct {
	mu        sync.Mutex          // Lock to protect shared access to this peer's state
	peers     []*labrpc.ClientEnd // RPC end points of all peers
	persister *Persister          // Object to hold this peer's persisted state
	me        int                 // this peer's index into peers[]
	dead      int32               // set by Kill()

	// 2A.
	state raftState
	term  int
	// -1 for null
	votedFor int

	// election timer for follower and candidate to start a election
	electionTime    time.Time
	electionTimeout time.Duration
	// only leader has a heartbeat timer
	HeartbeatTime time.Time
}
```

### 选举

```go
type RequestVoteArgs struct {
	// 候选者的任期
	Term int
	// 候选者 ID
	CandidateId int
}

type RequestVoteReply struct {
    // 选民的任期，用于候选者更新自己的任期
	Term int
	// 是否得到选票
	VoteGranted bool
}
```

#### 候选者 & 跟随者

当跟随者或候选者的选举定时器超时，便会转换成候选者，同时将自身的任期加 1

```go
if rf.state != Leader && time.Since(rf.electionTime) > rf.electionTimeout {
    rf.term++
    rf.state = Candidate
    Debug(dVote, "S%d become to Candidate", rf.me)
    rf.startElection()
}
```

然后向集群中所有的其他的服务器**同步**发送 RequestVote RPC

```go
for i := range rf.peers {
    if i == rf.me {
        continue
    }
    go func(server int) {
        reply := RequestVoteReply{}
        rf.sendRequestVote(server, &args, &reply)
        replyCh <- reply.VoteGranted
        if reply.Term > args.Term {
            rf.term = reply.Term
            rf.state = Follower
            Debug(dTerm, "C%d term is outdated, updating T%d->T%d", rf.me, args.Term, reply.Term)
        }
    }(i)
}
```

候选者发起选举后， 有三种结果

1.   获得大多数选票（半数以上），竞选成功，转换成领导者，同时向集群中其他服务器发送心跳包，建立领导者的权威

```go
// handle RequestVote reply
for reply := range replyCh {
    replyCnt++
    if reply {
        // get a vote
        grantedVote++
    }
    if replyCnt == all || grantedVote > all/2 || replyCnt-grantedVote > all/2 {
        break
    }
}

// not win the election
if grantedVote <= all/2 {
    return
}
// win
if rf.state == Candidate {
    rf.state = Leader
    go rf.startHeartbeat()
    Debug(dLeader, "C%d get majority votes (%d/%d), become to Leader", rf.me, grantedVote, all)
}
```

2.   选举定时器超时前未获得大多数选票，则进入下一个竞选周期到来，重复上述流程

3.   收到新领导者的心跳包，则转换成跟随者

#### 跟随者

当某个服务器收到候选者的 RequestVote RPC 时，它遵守以下规则来投出选票：

1.   每个 raft 节点有且仅有一个选票

2.   先到先得

```go
func (rf *Raft) RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) {
	Debug(dVote, "S%d received vote request from C%d at T%d", rf.me, args.CandidateId, rf.term)

	reply.Term = rf.term
	if args.Term < rf.term {
		return
	}

	if args.Term > rf.term {
		Debug(dTerm, "S%d term is outdated, updating T%d->T%d", rf.me, rf.term, args.Term)
		rf.votedFor = -1
		rf.state = Follower
	}

	// votedFor is not null or candidateId
	if rf.votedFor != -1 && rf.votedFor != args.CandidateId {
		return
	}

	// candidate get the vote
	reply.VoteGranted = true
	rf.term = args.Term
	rf.votedFor = args.CandidateId
	rf.state = Follower
	// reset timer
	rf.electionTime = time.Now()
	Debug(dVote, "S%d resetting ELT, granting vote to C%d at T%d", rf.me, args.CandidateId, rf.term)
	return
}
```

目前的流程还是比较简单的，只要任期和选票满足条件，就投出选票。然后重置自己的选举定时器。

### 心跳

```go
type AppendEntriesArgs struct {
	// 领导者任期
	Term int
	// 领导之 ID
	LeaderId int
}

type AppendEntriesReply struct {
	// 响应者的任期，用于领导者更新自己的状态
	Term int
	// 响应成功
	Success bool
}
```

#### 领导者

领导者会**周期性**的给集群中所有的其他服务器发送心跳包以确定集群的状态

```go
if rf.state == Leader && time.Since(rf.HeartbeatTime) > HeartbeatTimeout {
    rf.startHeartbeat()
}
```

心跳其实就是一个特殊的 AppendEntries，它的附加日志为空

```go
for i := range rf.peers {
    if i == rf.me {
        continue
    }
    go func(server int) {
        reply := AppendEntriesReply{}
        rf.sendAppendEntries(server, &args, &reply)
        if reply.Term > args.Term {
            rf.term = args.Term
            rf.state = Follower
            rf.electionTime = time.Now()
            Debug(dTerm, "L%d term is outdated, updating T%d->T%d", rf.me, args.Term, reply.Term)
        }
    }(i)
}
```

#### 候选者 & 跟随者

当其他节点收到领导者的**合法**心跳后变会重置自己的选举定时器

```go
func (rf *Raft) AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) {
	Debug(dLog, "S%d received append entries from L%d at T%d", rf.me, args.LeaderId, rf.term)

	reply.Term = rf.term
	if args.Term < rf.term {
		return
	}

	reply.Success = true
	rf.state = Follower
	rf.term = args.Term
	// reset timer
	rf.electionTime = time.Now()
	Debug(dTimer, "S%d resetting ELT, received ae from L%d at T%d", rf.me, args.LeaderId, rf.term)
	return
}
```

## 注意

1.   前面所有的代码片段都只是示意，并没有加锁
2.   上面的流程仅关注 2A 的实现，暂时不涉及日志的校验

### 任期

所有的 RPC，不管是发送者还是接收者，都需要校验任期，如果发现自己当前的任期如果过期了，需要更新任期，并且变成跟随者。

### 定时器

所有的跟随者和候选者都有一个选举定时器，一旦超时就会进行新的选举。同时，他们他们在收到**有效**的 RPCs 时，会重置定时器，这里的**有效**其实可以分为两种情况：

1.   将选票投给候选人
2.   收到合法领导人的心跳包

领导者会有一个心跳定时器，超时则开启广播，将心跳包发给集群其他节点，之后再重置。

### 日志

日志在调试过程中尤为重要，这里使用的是 [Debugging by Pretty Printing](https://blog.josejg.com/debugging-pretty/) 这篇文章的方法。

## 结果

![image-20220116115214632](C:\Users\18273\AppData\Roaming\Typora\typora-user-images\6.824-2A-result.png)

## 参考

1.   https://pdos.csail.mit.edu/6.824/labs/lab-raft.html
2.   https://thesquareplanet.com/blog/students-guide-to-raft/
3.   https://pdos.csail.mit.edu/6.824/labs/raft-locking.txt
4.   https://pdos.csail.mit.edu/6.824/labs/raft-structure.txt
5.   https://blog.josejg.com/debugging-pretty/

