---
title: "Goleveldb源码分析（三）布隆过滤器"
date: 2022-04-01T08:19:43+08:00
categories: [goleveldb]
tags: [go, 读点源码]
draft: true
---

布隆过滤器是一种空间效率很高的随机数据结构，它利用位数组很简洁地表示一个集合，并能判断一个元素是否属于这个集合。布隆过滤器的这种高效是有一定代价的：在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合（false positive）。因此，布隆过滤器不适合那些**零错误**的应用场合。而在能容忍低错误率的应用场合下，布隆过滤器通过极少的错误换取了存储空间的极大节省。

Leveldb中利用布隆过滤器判断指定的key值是否存在于sstable中，若过滤器表示不存在，则该key一定不存在，由此加快了查找的效率。

## 结构

布隆过滤器底层是一个位数组，初始时每一位都是0

![img](https://cdn.jsdelivr.net/gh/wuliuqii/pic@master/img/bloom1.jpg)

当插入值x后，分别利用k个哈希函数（图中为3）利用x的值进行散列，并将散列得到的值与布隆过滤器的容量进行取余，将取余结果所代表的那一位值置为1。

![img](https://cdn.jsdelivr.net/gh/wuliuqii/pic@master/img/bloom2.jpg)

一次查找过程与一次插入过程类似，同样利用k个哈希函数对所需要查找的值进行散列，只有散列得到的每一个位的值均为1，才表示该值“**有可能**”真正存在；反之若有任意一位的值为0，则表示该值一定不存在。例如y1一定不存在；而y2可能存在。

![img](https://cdn.jsdelivr.net/gh/wuliuqii/pic@master/img/bloom3.jpg)

## 数学结论[^1]

首先，与布隆过滤器准确率有关的参数有：

-   哈希函数的个数k；
-   布隆过滤器位数组的容量m;
-   布隆过滤器插入的数据数量n。

主要的数学结论有：

1.  为了获得最优的准确率，当$k = ln2 * (m/n$)时，布隆过滤器获得最优的准确性；
2.  在哈希函数的个数取到最优时，要让错误率不超过є，m至少需要取到最小值的1.44倍。

## 实现

goleveldb中，布隆过滤器的定义只是一个int数字

```go
type bloomFilter int
```

创建一个布隆过滤器时，只需要指定为每个key分配的位数即可，如结论2所示，只要该值（m/n）大于1.44即可，一般可以取10。

```go
func NewBloomFilter(bitsPerKey int) Filter {
    return bloomFilter(bitsPerKey)
}
```

创建一个Generator, 这一步中需要指定哈希函数的个数k，可以看到$k = f * ln2$，而$f = m/n$，即数学结论1。

返回的Generator中可以添加新的key信息，调用Generate函数时，将所有的key构建成一个位数组写在指定的位置。

```go
type bloomFilterGenerator struct {
	n int   // 插入的数据量
	k uint8 // hash 函数的个数

	keyHashes []uint32
}

func (f bloomFilter) NewGenerator() FilterGenerator {
    // Round down to reduce probing cost a little bit.
    k := uint8(f * 69 / 100) // 0.69 =~ ln(2)
    if k < 1 {
        k = 1
    } else if k > 30 {
        k = 30
    }
    return &bloomFilterGenerator{
        n: int(f),
        k: k,
    }
}
```

Generator主要有两个函数：

1.  Add
2.  Generate

Add函数中，只是简单地将key的哈希散列值存储在一个整型数组中

```go
func (g *bloomFilterGenerator) Add(key []byte) {
    // Use double-hashing to generate a sequence of hash values.
    // See analysis in [Kirsch,Mitzenmacher 2006].
    g.keyHashes = append(g.keyHashes, bloomHash(key))
}
```

Generate函数中，将之前一段时间内所有添加的key信息用来构建一个位数组，该位数组中包含了所有key的存在信息。

位数组的大小为用户指定的每个key所分配的位数乘以 key的个数。

位数组的最末尾用来存储k的大小。

```go
func (g *bloomFilterGenerator) Generate(b Buffer) {
	// Compute bloom filter size (in both bits and bytes)
	nBits := uint32(len(g.keyHashes) * g.n)
	// For small n, we can see a very high false positive rate.  Fix it
	// by enforcing a minimum bloom filter length.
	// nBits太小，容错率大大降低
	if nBits < 64 {
		nBits = 64
	}
	// 向上取整
	nBytes := (nBits + 7) / 8
	nBits = nBytes * 8

	dest := b.Alloc(int(nBytes) + 1)
	// 最后一个byte放k
	dest[nBytes] = g.k
	for _, kh := range g.keyHashes {
		delta := (kh >> 17) | (kh << 15) // Rotate right 17 bits
		for j := uint8(0); j < g.k; j++ {
			bitpos := kh % nBits
			dest[bitpos/8] |= (1 << (bitpos % 8))
			kh += delta
		}
	}

	g.keyHashes = g.keyHashes[:0]
}
```

Contain函数用来判断指定的key是否存在。

```go
func (f bloomFilter) Contains(filter, key []byte) bool {
    nBytes := len(filter) - 1
    if nBytes < 1 {
        return false
    }
    nBits := uint32(nBytes * 8)

    // Use the encoded k so that we can read filters generated by
    // bloom filters created using different parameters.
    k := filter[nBytes]
    if k > 30 {
        // Reserved for potentially new encodings for short bloom filters.
        // Consider it a match.
        return true
    }

    kh := bloomHash(key)
    delta := (kh >> 17) | (kh << 15) // Rotate right 17 bits
    for j := uint8(0); j < k; j++ {
        bitpos := kh % nBits
        if (uint32(filter[bitpos/8]) & (1 << (bitpos % 8))) == 0 {
            return false
        }
        kh += delta
    }
    return true
}
```

布隆过滤器整体来说比较简单，主要就是数学结论，但咱们只看实现。外围的一些比较重要的概念咱们算是看完了，接下来就要看数据库的核心实现了。

[^1]: http://blog.csdn.net/jiaomeng/article/details/1495500
