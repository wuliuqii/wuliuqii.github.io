---
title: "Ostep  Virtualization"
date: 2020-04-02T10:34:27+08:00
draft: false
categories: [OS]
math: true
---

## CPU 虚拟化

操作系统通过低级机制和高级策略实现 CPU 虚拟化。机制就是一些低级方法和协议，如上下切换，时分共享。策略是在操作系统中作出某种决定的算法。

>   你可以将机制看 成为系统的“如何（how）”问题提供答案。例如，操作系统如何执行上下文切换？策略为“哪个（which）” 问题提供答案。例如，操作系统现在应该运行哪个进程？将两者分开可以轻松地改变策略，而不必重新考虑机制，因此这是一种模块化（modularity）的形式，一种通用的软件设计原则。

## 进程

进程：运行中的程序。

进程 API 包括：创建（create）、销毁（destroy）、等待（wait）、其他控制（miscellaneous control）、状态（statu）。

### 进程创建

操作系统如何启动并运行一个进程？

操作系统运行程序必须做的第一件事是将代码和所有静态数据（例如初始化变量）加载到内存中，加载到进程的地址空间中。程序最初以某种可执行格式驻留在磁盘上 （disk，或者在某些现代系统中，在基于闪存的 SSD 上）。因此，将程序和静态数据加载到内存中的过程，需要操作系统从磁盘读取这些字节，并将它们放在内存中的某处（见下图）

![从程序到进程](https://cdn.jsdelivr.net/gh/GallonHu/pic@master/blog/从程序到进程.png)

将代码和静态数据加载到内存后，操作系统在运行此进程之前还需要执行其他一些操作，为程序的运行时栈（runtime stack）和堆分配一些内存。在 C 程序使用栈存放局部变量、函数参数和返回地址。操作系统分配这些内存，并提供给进程。 操作系统也可能会用参数初始化栈。具体来说，它会将参数填入 main()函数，即 argc 和 argv 数组。堆用于显式请求的动态分配数据。程序通过调用 malloc() 来请求这样的空间，并通过调用 free() 来明确地释放它。数据结构（如链表、散列表、树和其他有趣的数据结构）需要堆。起初堆会很小。随着程序运行，通过 malloc() 请求更多内存，操作系统可能会参与分配更多内存给进程，以满足这些调用。

操作系统还将执行一些其他初始化任务，特别是与输入/输出（I/O）相关的任务。例如，在 UNIX 系统中，默认情况下每个进程都有 3 个打开的文件描述符（file descriptor），用于标准输入、输出和错误。

通过将代码和静态数据加载到内存中，通过创建和初始化栈以及执行与 I/O 设置相关的其他工作，OS 现在（终于）为程序执行搭好了舞台。然后它有最后一项任务：启动程序， 在入口处运行，即 main()。通过跳转到 main()例程，OS 将 CPU 的控制权转移到新创建的进程中，从而程序开始执行。

### 进程状态

进程可以处于以下 3 种状态之一。 

-   运行（running）：在运行状态下，进程正在处理器上运行。这意味着它正在执行指令。 

-   就绪（ready）：在就绪状态下，进程已准备好运行，但由于某种原因，操作系统选择不在此时运行。

-   阻塞（blocked）：在阻塞状态下，一个进程执行了某种操作，直到发生其他事件时才会准备运行。一个常见的例子是，当进程向磁盘发起 I/O 请求时，它会被阻塞， 因此其他进程可以使用处理器。

如果将这些状态映射到一个图上，会得到下图。如图所示，可以根据操作系统的载量，让进程在就绪状态和运行状态之间转换。从就绪到运行意味着该进程已经被调度（scheduled）。从运行转移到就绪意味着该进程已经取消调度（descheduled）。一旦进程被阻塞（例如，通过发起 I/O 操作），OS 将保持进程的这种状态，直到发生某种事件（例如，I/O 完成）。此时，进程再次转入就绪状态（也可能立即再次运行，如果操作系统这样决定）。  

![进程状态转换](https://cdn.jsdelivr.net/gh/GallonHu/pic@master/blog/进程状态转换.png)

### 进程 API

UNIX 系统采用了一种非常有趣的创建新进程的 方式，即通过一对系统调用：fork()和 exec()。进程还可以通过第三个系统调用 wait()，来等 待其创建的子进程执行完成。

系统调用 fork()用于创建新进程，子进程并不是完全拷贝了父进程。具体来说，虽然它拥有自己的 地址空间（即拥有自己的私有内存）、寄存器、程序计数器等，但是它从 fork()返回的值是 我同的。父进程获得的返回值是新创建子进程的 PID，而子进程获得的返回值是 0。

子进程被创建后，我我就需 要关心系统中的两个活动进程了：子进程和父进程。假设我我谁单个 CPU 的系统上运行（简 单起见），那谁子进程或父进程谁此谁都有可能运行。CPU 调度程序（scheduler）决我了某个谁刻哪个进程被执行。

父进程调用 wait()，延迟自己的执行，直到子进程执行完毕。当子进 程结束谁，wait()才返回父进程。

exec() 可以让子进程执行与父进程不同的程序。给定可执行程序的名称（如 wc）及 需要的参数（如 p3.c）后，exec() 会从可执行程序中加载代码和静态数据，并用它覆写自己 的代码段（以及静态数据），堆、栈及其他内存空间也会被重新初始化。然后操作系统就执行该程序，将参数通过 argv 传递给该进程。因此，它并没有创建新进程，而是直接将当前运行的程序（以前的 p3）替换为不同的运行程序（wc）。

### 机制：受限直接执行

CPU 虚拟化中的问题：

1.  性能：如何在不增加系统开销的情况下实现虚拟化？
2.  控制权：如何有效地运行进程，同时保留对 CPU 的控制？

#### 直接执行

只需直接在 CPU 上运行程序即可。因此，当 OS 希望启动程序运行时，它会在进程列表中为其创建一个进程条目，为其分配一些内存，将程序代码（从磁盘）加载到内存中，找到入口点（main()函数或类似的），跳转到那里，并开始运行用户的代码。

这仍然会带来两个问题：

1.  操作系统怎么能确保程序不做任何我们不希望它做的事，同时仍然高效地运行它？
2.  当我们运行一个进程时，操作系统如何让它停下来并切换到另一个进程，从而实现虚拟化 CPU 所需的时分共享？

#### 受限的操作

硬件通过提供不同的执行模式来协助操作系统。在用户模式（user mode）下，应用程序不能完全访问硬件资源。在内核模式（kernel mode）下，操作系统可以访问机器的全部资源。还提供了陷入（trap） 内核和从陷阱返回（return-from-trap）到用户模式程序的特别说明，以及一些指令，让操作系统告诉硬件陷阱表（trap table）在内存中的位置。

**陷阱如何知道在 OS 内运行哪些代码？**

内核通过在启动时设置陷阱表（trap table）来实现。当机器启动时，它在特权（内核）模式下执行，因此可以根据需要自由配置机器硬件。操作系统做的第一件事，就是告诉硬件在发生某些异常事件时要运行哪些代码。例如，当发生硬盘中断，发生键盘中断或程序进行系统调用时，应该运行哪些代码？操作系统通常通过某种特殊的指令，通知硬件这些陷阱处理 程序的位置。一旦硬件被通知，它就会记住这些处理程序的位置，直到下一次重新启动机器， 并且硬件知道在发生系统调用和其他异常事件时要做什么（即跳转到哪段代码）。

#### 在进程间切换

**操作系统如何重新获得 CPU 的控制权（regain control），以便它可以在进程之间切换？**

**协作方式：等待系统调用** 

过去某些系统采用的一种称为协作（cooperative）方式。在这种风格下，操作系统相信系统的进程会合理运行。运行时间过长的进程被假定会定期放弃 CPU，以便操作系统可以决定运行其他任务。

大多数进程通过进行系统调用，将 CPU 的控制权转移给操作系统，例如打开文件并随后读取文件，或者向另一台机器发送消息或创建新进程。像这样的系统通常包括一个显式的 yield 系统调用，它什么都不干，只是将控制权交给操作系统，以便系统可以运行其他进程。

**非协作方式：操作系统进行控制** 

**如果进程不协作，操作系统如何获得 CPU 的控制权？操作系统可以做什么来确保流氓进程不会占用机器？**

时钟中断（timer interrupt）。时钟设备可以编程为每隔几毫秒产生一次中断。产生中断时，当前正在运行的进 程停止，操作系统中预先配置的中断处理程序（interrupt handler）会运行。此时，操作系统 重新获得 CPU 的控制权，因此可以做它想做的事：停止当前进程，并启动另一个进程。

#### 保存上下文

既然操作系统已经重新获得了控制权，无论是通过系统调用协作，还是通过时钟中断 更强制执行，都必须决定：是继续运行当前正在运行的进程，还是切换到另一个进程。

如果决定进行切换，OS 就会执行一些底层代码，即所谓的上下文切换（context switch）。 上下文切换在概念上很简单：操作系统要做的就是为当前正在执行的进程保存一些寄存器的值（例如，到它的内核栈），并为即将执行的进程恢复一些寄存器的值（从它的内核栈）。 这样一来，操作系统就可以确保最后执行从陷阱返回指令时，不是返回到之前运行的进程， 而是继续执行另一个进程。

为了保存当前正在运行的进程的上下文，操作系统会执行一些底层汇编代码，来保存通用寄存器、程序计数器，以及当前正在运行的进程的内核栈指针，然后恢复寄存器、程序计数器，并切换内核栈，供即将运行的进程使用。通过切换栈，内核在进入切换代码调用时，是一个进程（被中断的进程）的上下文，在返回时，是另一进程（即将执行的进程） 的上下文。当操作系统最终执行从陷阱返回指令时，即将执行的进程变成了当前运行的进程。至此上下文切换完成。

#### 并发问题

在系统调用期间发生时 钟中断时会发生什么？

处理一个中断时发生另一个中断，会发生什么？

### 进程调度

事实上，调度的起源要早于计算机系统。早期调度策略取自于操作管理领域，并应用于计算机。在现在的许多框架中，调度策略都是少不了的。这里我们将简单的介绍几种进程调度策略。

在介绍具体的调度策略之前，我们应该有个明确的认知，所谓的调度，本质上就是优化。既然是优化，那肯定要有优化对象，比如时间，空间等等。这里，我们先引入一个时间指标：
$$
T_{周转时间}=T_{完成时间}-T_{开始时间}
$$
为了叙述的方便，这里再对进程（有时也叫工作）做出几个假设：

1.  每一个工作运行相同的时间。
2.  所有的工作同时到达。
3.  一旦开始，每个工作保持运行直到完成。
4.  所有的工作只是用 CPU（即它们不执行 IO 操作）。
5.  每个工作的运行时间是已知的。

当然，以上的所有假设在实际中肯定是不可能存在的，后面也会结合实际情况慢慢优化我们的假设。

#### 先进先出（FIFO）

最先想到的算法肯定是先进先出（First In First Out）调度，它根据任务到达的先后依次运行。

FIFO有一些积极的特性：简单且易于实现

![FIFO](https://cdn.jsdelivr.net/gh/GallonHu/pic@master/blog/FIFO简单例子.png)

#### 最短任务优先（SJF）



#### 最短完成时间优先（STCF）



#### 轮询（RR）



### 多级反馈队列（MLFQ）

