<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>go on wuliuqi</title>
    <link>https://wuliuqii.github.io/tags/go/</link>
    <description>Recent content in go on wuliuqi</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 05 Apr 2022 09:13:33 +0800</lastBuildDate><atom:link href="https://wuliuqii.github.io/tags/go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Goleveldb源码分析（四）日志</title>
      <link>https://wuliuqii.github.io/posts/goleveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9B%9B%E6%97%A5%E5%BF%97/</link>
      <pubDate>Tue, 05 Apr 2022 09:13:33 +0800</pubDate>
      
      <guid>https://wuliuqii.github.io/posts/goleveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9B%9B%E6%97%A5%E5%BF%97/</guid>
      <description>为了防止写入内存的数据库因为进程异常、系统掉电等情况发生丢失，Leveldb在写内存之前会将本次写操作的内容写入日志文件中。
在Leveldb中，有两个memory db，以及对应的两份日志文件。其中一个memory db是可读写的，当这个db的数据量超过预定的上限时，便会转换成一个不可写的memory db，与此同时，与之对应的日志文件也变成一份frozen log。
而新生成的immutable memory db则会由后台的minor compaction进程将其转换成一个sstable文件进行持久化，持久化完成，与之对应的frozen log被删除。
在本文中主要分析日志的结构、写入读取操作。
日志结构 为了增加读取效率，日志文件中按照block进行划分，每个block的大小为32KiB。每个block中包含了若干个完整的chunk。
一条日志记录包含一个或多个chunk。每个chunk包含了一个7字节大小的header，前4字节是该chunk的校验码，紧接的2字节是该chunk数据的长度，以及最后一个字节是该chunk的类型。其中checksum校验的范围包括chunk的类型以及随后的data数据。
chunk共有四种类型：full，first，middle，last。一条日志记录若只包含一个chunk，则该chunk的类型为full。若一条日志记录包含多个chunk，则这些chunk的第一个类型为first, 最后一个类型为last，中间包含大于等于0个middle类型的chunk。
由于一个block的大小为32KiB，因此当一条日志文件过大时，会将第一部分数据写在第一个block中，且类型为first，若剩余的数据仍然超过一个block的大小，则第二部分数据写在第二个block中，类型为middle，最后剩余的数据写在最后一个block中，类型为last。
日志写 日志写入流程较为简单，在leveldb内部，实现了一个journal的writer。首先调用Next函数获取一个singleWriter，这个singleWriter的作用就是写入一条journal记录。
singleWriter开始写入时，标志着第一个chunk开始写入。在写入的过程中，不断判断writer中buffer的大小，若超过32KiB，将chunk开始到现在做为一个完整的chunk，为其计算header之后将整个chunk写入文件。与此同时reset buffer，开始新的chunk的写入。
若一条journal记录较大，则可能会分成几个chunk存储在若干个block中。
type Writer struct { 	w io.Writer 	// 充当逻辑时钟 	seq int 	f flusher 	// buf[i:j] 表示当前的chunk，i下标包括chunk header 	i, j int 	// 已经写入的下标 	written int 	// 是否为第一个chunk 	first bool 	// 是否数据已经写入buf，但是还没有落盘（当前block未满32KiB） 	pending bool 	err error 	// 每个block为32KiB 	buf [blockSize]byte }  // chunk header: // +-------------------+-----------------+--------------------+ // | Checksum(4-bytes) | Length(2-bytes) | Chunk type(1-byte) | // +-------------------+-----------------+--------------------+ func (w *Writer) fillHeader(last bool) { 	if w.</description>
    </item>
    
    <item>
      <title>Goleveldb源码分析（三）布隆过滤器</title>
      <link>https://wuliuqii.github.io/posts/goleveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</link>
      <pubDate>Fri, 01 Apr 2022 08:19:43 +0800</pubDate>
      
      <guid>https://wuliuqii.github.io/posts/goleveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</guid>
      <description>布隆过滤器是一种空间效率很高的随机数据结构，它利用位数组很简洁地表示一个集合，并能判断一个元素是否属于这个集合。布隆过滤器的这种高效是有一定代价的：在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合（false positive）。因此，布隆过滤器不适合那些零错误的应用场合。而在能容忍低错误率的应用场合下，布隆过滤器通过极少的错误换取了存储空间的极大节省。
Leveldb中利用布隆过滤器判断指定的key值是否存在于sstable中，若过滤器表示不存在，则该key一定不存在，由此加快了查找的效率。
结构 布隆过滤器底层是一个位数组，初始时每一位都是0
当插入值x后，分别利用k个哈希函数（图中为3）利用x的值进行散列，并将散列得到的值与布隆过滤器的容量进行取余，将取余结果所代表的那一位值置为1。
一次查找过程与一次插入过程类似，同样利用k个哈希函数对所需要查找的值进行散列，只有散列得到的每一个位的值均为1，才表示该值“有可能”真正存在；反之若有任意一位的值为0，则表示该值一定不存在。例如y1一定不存在；而y2可能存在。
数学结论1 首先，与布隆过滤器准确率有关的参数有：
 哈希函数的个数k； 布隆过滤器位数组的容量m; 布隆过滤器插入的数据数量n。  主要的数学结论有：
 为了获得最优的准确率，当$k = ln2 * (m/n$)时，布隆过滤器获得最优的准确性； 在哈希函数的个数取到最优时，要让错误率不超过є，m至少需要取到最小值的1.44倍。  实现 goleveldb中，布隆过滤器的定义只是一个int数字
type bloomFilter int 创建一个布隆过滤器时，只需要指定为每个key分配的位数即可，如结论2所示，只要该值（m/n）大于1.44即可，一般可以取10。
func NewBloomFilter(bitsPerKey int) Filter {  return bloomFilter(bitsPerKey) } 创建一个Generator, 这一步中需要指定哈希函数的个数k，可以看到$k = f * ln2$，而$f = m/n$，即数学结论1。
返回的Generator中可以添加新的key信息，调用Generate函数时，将所有的key构建成一个位数组写在指定的位置。
type bloomFilterGenerator struct { 	n int // 插入的数据量 	k uint8 // hash 函数的个数  	keyHashes []uint32 }  func (f bloomFilter) NewGenerator() FilterGenerator {  // Round down to reduce probing cost a little bit.</description>
    </item>
    
    <item>
      <title>Goleveldb源码分析（二）缓存</title>
      <link>https://wuliuqii.github.io/posts/goleveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%BA%8C%E7%BC%93%E5%AD%98/</link>
      <pubDate>Thu, 31 Mar 2022 08:30:43 +0800</pubDate>
      
      <guid>https://wuliuqii.github.io/posts/goleveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%BA%8C%E7%BC%93%E5%AD%98/</guid>
      <description>缓存主要的功能就是减少磁盘IO。Leveldb中使用了一种基于LRUCache的缓存机制，用于缓存：
 已打开的sstable文件对象和相关元数据； sstable中的dataBlock的内容。  整体结构 Leveldb中使用的Cache是一种LRUcache，其结构由两部分内容组成：
 Hash table：用来存储数据； LRU：用来维护数据项的新旧信息。   缓存系统：
// 缓存 type Cache struct { 	mu sync.RWMutex // 读写锁 	mHead unsafe.Pointer // *mNode 指向哈希表 	nodes int32 // 哈希表中的节点个数 	size int32 // 哈希表大小 	cacher Cacher // 缓存策略 	closed bool // 是否关闭 } 缓存策略：
// 缓存策略接口，并发安全 // 以下的缓存皆指缓存策略 type Cacher interface { 	// 缓存容量 	Capacity() int  	// 设置缓存容量 	SetCapacity(capacity int)  	// 添加节点的到缓存中 	Promote(n *Node)  	// 将节点从缓存中删除，并尝试将其从哈希表中删除 	Ban(n *Node)  	// 将节点从缓存中删除 	Evict(n *Node)  	// 将所有给定的命名空间的节点从缓存中删除 	EvictNS(ns uint64)  	// 将缓存中的所有节点删除 	EvictAll()  	// 关闭缓存 	Close() error } 实现 再依次看一下上述各个结构实现与核心方法，以及如何组合在一起对外提供缓存的功能。</description>
    </item>
    
    <item>
      <title>Goleveldb源码分析（一）编码</title>
      <link>https://wuliuqii.github.io/posts/goleveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%80%E7%BC%96%E7%A0%81/</link>
      <pubDate>Thu, 31 Mar 2022 08:30:25 +0800</pubDate>
      
      <guid>https://wuliuqii.github.io/posts/goleveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%80%E7%BC%96%E7%A0%81/</guid>
      <description>研究一下基于Go语言的Leveldb的源码，参考作者的配套wiki。
Leveldb的整体流程如下图所示 基础 先从一些外围基础的概念开始看起。
编码 Leveldb使用encoding/binary标准库对数据进行编解码，这里将详细介绍它的规则。
大小端 字节序简单来说就是多字节对象在内存中的排列顺序，主要分为两种，大端序和小端序。
大端序，高位存在较大地址处。 示例中，最高位字节是0x0A 存储在最低的内存地址处。下一个字节0x0B存在后面的地址处。正类似于十六进制字节从左到右的阅读顺序。
小端序，低位存在较大地址处。 最低位字节是0x0D 存储在最低的内存地址处。后面字节依次存在后面的地址处。
在encoding/binary中定义了字节序的接口，同时也定义了大小端
type ByteOrder interface { 	Uint16([]byte) uint16 	Uint32([]byte) uint32 	Uint64([]byte) uint64 	PutUint16([]byte, uint16) 	PutUint32([]byte, uint32) 	PutUint64([]byte, uint64) 	String() string }  type littleEndian struct{} var LittleEndian littleEndian  type bigEndian struct{} var BigEndian bigEndian 看下编码的实例
package main  import ( 	&amp;#34;encoding/binary&amp;#34; 	&amp;#34;fmt&amp;#34; )  func BigEndian() { // 大端序 	// 二进制形式：0000 0000 0000 0000 0001 0002 0003 0004 	var testInt int32 = 0x01020304 // 十六进制表示 	fmt.</description>
    </item>
    
  </channel>
</rss>
