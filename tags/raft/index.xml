<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Raft on wuliuqi</title>
    <link>https://wuliuqii.github.io/tags/raft/</link>
    <description>Recent content in Raft on wuliuqi</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 30 Apr 2022 16:19:01 +0800</lastBuildDate><atom:link href="https://wuliuqii.github.io/tags/raft/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Tinykv（一）Standalone KV</title>
      <link>https://wuliuqii.github.io/posts/tinykv%E4%B8%80standalone-kv/</link>
      <pubDate>Sat, 30 Apr 2022 16:19:01 +0800</pubDate>
      
      <guid>https://wuliuqii.github.io/posts/tinykv%E4%B8%80standalone-kv/</guid>
      <description>TinyKV 是基于 TiKV 的 mini 版分布式 kv 数据库存储部分，是 tikv Talent Plan 课程的一部分。
TinyKV 的架构如下图所示：
Project1 主要是实现 Standalone Storage 以及 Raw API 这两部分。
Standalone Storage Standalone KV 基于 badger，实现了 Storage 接口
type Storage interface { Start() error Stop() error Write(ctx *kvrpcpb.Context, batch []Modify) error Reader(ctx *kvrpcpb.Context) (StorageReader, error) } 这里需要说一下的是，增加和删除的操作都是通过 Write 方法实现，区别这两种操作的方法是 batch 参数不一样
// Modify is a single modification to TinyKV&amp;#39;s underlying storage. type Modify struct { Data interface{} } type Put struct { Key []byte Value []byte Cf string } type Delete struct { Key []byte Cf string } Reader 方法返回的是一个 StorageReader 接口，可以实现单个 key 以及 iteration 的查询方式</description>
    </item>
    
    <item>
      <title>6.824 Lab2A</title>
      <link>https://wuliuqii.github.io/posts/6.824-lab2a/</link>
      <pubDate>Mon, 10 Jan 2022 23:37:13 +0800</pubDate>
      
      <guid>https://wuliuqii.github.io/posts/6.824-lab2a/</guid>
      <description>6.824 Lab 2A 课程主页: https://pdos.csail.mit.edu/6.824/schedule.html
Lab2: https://pdos.csail.mit.edu/6.824/labs/lab-raft.html
论文: https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf
要求 raft 算法通过领导人机制，将一致性问题分解成了三个相对独立的子问题：
领导选举 日志复制 安全性 Lab 2A 主要的任务就是实现 raft 的选主算法。
raft 基础 raft 集群中的服务器节点都处于一下三个状态之一：领导人、跟随者和候选人。正常的情况中，系统中应该只有一个领导人，并且其他节点都是跟随者。跟随者被动响应来着领导人或候选人的请求。领导人和客户端交互。候选人在选举新领导人的时候出现。
raft 把时间分割成任意长度的任期。任期用连续的整数标记。每一段任期从一次选举开始，一个或者多个候选人尝试成为领导人。如果一个候选人赢得选举，然后他就在接下来的任期内充当领导人的职责。在某些情况下，一次选举过程会造成选票的瓜分。在这种情况下，这一任期会以没有领导人结束；一个新的任期（和一次新的选举）会很快重新开始。raft 保证了在一个给定的任期内，最多只有一个领导人。
实现 2A 中，只关注选举的过程，所以我们目前仅关注部分参数以及选举和心跳流程。
type Raft struct { mu sync.Mutex // Lock to protect shared access to this peer&amp;#39;s state peers []*labrpc.ClientEnd // RPC end points of all peers persister *Persister // Object to hold this peer&amp;#39;s persisted state me int // this peer&amp;#39;s index into peers[] dead int32 // set by Kill() // 2A.</description>
    </item>
    
    <item>
      <title>6.824 lab1</title>
      <link>https://wuliuqii.github.io/posts/6.824-lab1/</link>
      <pubDate>Sun, 09 May 2021 20:30:53 +0800</pubDate>
      
      <guid>https://wuliuqii.github.io/posts/6.824-lab1/</guid>
      <description>6.824 Lab 1 课程主页: https://pdos.csail.mit.edu/6.824/schedule.html
Lab1: https://pdos.csail.mit.edu/6.824/labs/lab-mr.html
论文: http://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf
要求 lab 1 主要是实现一个简易版 MapReduce 系统，主要有两部分：
worker：map、reduce 函数执行 ，文件读写处理 coordinate：任务调度 测试用例会有任务超时和 crash 的情况，需要有容错机制 整个流程大概可以简化成如下几步：
启动 coordinate 进程，监听 worker 请求 启动单个或多个 worker 进程，worker 向 coordinate 请求任务 coordinate 处理 worker 的任务请求，步骤如下： 判断 map 任务是否全部完成 若未完成，挑选一个未完成的 map 任务，并将该任务状态设置为 assigned；否则判断 reduce 任务是否全部完成 若未完成，挑选一个未完成的 reduce 任务，并将该任务状态设置为 assigned worker 收到任务后，根据任务类型执行对应的函数（map、reduce、wait） worker 完成任务后，向 coordinate 发送任务已完成 coordinate 将相应完成的任务的状态标记为 finished 重复 1-6 直至所有任务完成 worker worker 不断向 coordinate 请求任务，根据返回的任务进行处理，主体程序如下：
func Worker(mapf func(string, string) []KeyValue, reducef func(string, []string) string) { for { args := RequestArgs{MessageType: RequestTask} reply := RequestReply{} err := call(&amp;#34;Coordinator.</description>
    </item>
    
  </channel>
</rss>
