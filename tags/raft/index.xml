<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Raft on wuliuqi</title>
    <link>https://wuliuqii.github.io/tags/raft/</link>
    <description>Recent content in Raft on wuliuqi</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 10 Jan 2022 23:37:13 +0800</lastBuildDate><atom:link href="https://wuliuqii.github.io/tags/raft/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>6.824 Lab2A</title>
      <link>https://wuliuqii.github.io/posts/6.824-lab2a/</link>
      <pubDate>Mon, 10 Jan 2022 23:37:13 +0800</pubDate>
      
      <guid>https://wuliuqii.github.io/posts/6.824-lab2a/</guid>
      <description>6.824 Lab 2A 课程主页: https://pdos.csail.mit.edu/6.824/schedule.html
Lab2: https://pdos.csail.mit.edu/6.824/labs/lab-raft.html
论文: https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf
要求 raft 算法通过领导人机制，将一致性问题分解成了三个相对独立的子问题：
 领导选举 日志复制 安全性  Lab 2A 主要的任务就是实现 raft 的选主算法。
raft 基础 raft 集群中的服务器节点都处于一下三个状态之一：领导人、跟随者和候选人。正常的情况中，系统中应该只有一个领导人，并且其他节点都是跟随者。跟随者被动响应来着领导人或候选人的请求。领导人和客户端交互。候选人在选举新领导人的时候出现。
raft 把时间分割成任意长度的任期。任期用连续的整数标记。每一段任期从一次选举开始，一个或者多个候选人尝试成为领导人。如果一个候选人赢得选举，然后他就在接下来的任期内充当领导人的职责。在某些情况下，一次选举过程会造成选票的瓜分。在这种情况下，这一任期会以没有领导人结束；一个新的任期（和一次新的选举）会很快重新开始。raft 保证了在一个给定的任期内，最多只有一个领导人。
实现 2A 中，只关注选举的过程，所以我们目前仅关注部分参数以及选举和心跳流程。
type Raft struct { 	mu sync.Mutex // Lock to protect shared access to this peer&amp;#39;s state 	peers []*labrpc.ClientEnd // RPC end points of all peers 	persister *Persister // Object to hold this peer&amp;#39;s persisted state 	me int // this peer&amp;#39;s index into peers[] 	dead int32 // set by Kill()  	// 2A.</description>
    </item>
    
    <item>
      <title>6.824 lab1</title>
      <link>https://wuliuqii.github.io/posts/6.824-lab1/</link>
      <pubDate>Sun, 09 May 2021 20:30:53 +0800</pubDate>
      
      <guid>https://wuliuqii.github.io/posts/6.824-lab1/</guid>
      <description>6.824 Lab 1 课程主页: https://pdos.csail.mit.edu/6.824/schedule.html
Lab1: https://pdos.csail.mit.edu/6.824/labs/lab-mr.html
论文: http://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf
要求 lab 1 主要是实现一个简易版 MapReduce 系统，主要有两部分：
 worker：map、reduce 函数执行 ，文件读写处理 coordinate：任务调度 测试用例会有任务超时和 crash 的情况，需要有容错机制  整个流程大概可以简化成如下几步：
 启动 coordinate 进程，监听 worker 请求 启动单个或多个 worker 进程，worker 向 coordinate 请求任务 coordinate 处理 worker 的任务请求，步骤如下：  判断 map 任务是否全部完成 若未完成，挑选一个未完成的 map 任务，并将该任务状态设置为 assigned；否则判断 reduce 任务是否全部完成 若未完成，挑选一个未完成的 reduce 任务，并将该任务状态设置为 assigned   worker 收到任务后，根据任务类型执行对应的函数（map、reduce、wait） worker 完成任务后，向 coordinate 发送任务已完成 coordinate 将相应完成的任务的状态标记为 finished 重复 1-6 直至所有任务完成  worker worker 不断向 coordinate 请求任务，根据返回的任务进行处理，主体程序如下：</description>
    </item>
    
  </channel>
</rss>
